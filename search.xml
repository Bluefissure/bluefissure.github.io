<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>blog-migration</title>
      <link href="/2018/11/13/blog-migration/"/>
      <url>/2018/11/13/blog-migration/</url>
      
        <content type="html"><![CDATA[<h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><p>从Vultr迁移到了Github Pages</p><p>从WordPress迁移到了Hexo</p><p>从济南迁移到了杭州</p><p>从学生迁移到了社畜</p><p>从咸鱼迁移到了更咸的鱼</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>LeetCode.857 Minimum Cost to Hire K Workers</title>
      <link href="/2018/10/17/leetcode-857-minimum-cost-to-hire-k-workers/"/>
      <url>/2018/10/17/leetcode-857-minimum-cost-to-hire-k-workers/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/minimum-cost-to-hire-k-workers/" target="_blank" rel="noopener">题目地址</a></p><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>n个人，每个人有wage和quality，选择K个人按照quality比发放工资，要求到手的工资不少于各自的wage，求最小花费。</p><a id="more"></a><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>考虑选中的K个人中，如果以满足第$i$个人的wage为标准发放工资，则最后的花费$Q$为： </p><script type="math/tex; mode=display">Q=\sum _{ k }^{ K }{ { q }_{ k } } \cdot \frac { { w }_{ i } }{ { q }_{ i } }</script><p>为了满足其他人的工资不低于各自的wage: </p><script type="math/tex; mode=display">\frac { { w }_{ i } }{ { q }_{ i } } \cdot {q}_{j} \ge {w}_{j} (j\neq i)</script><p>即 </p><script type="math/tex; mode=display">\frac { { w }_{ i } }{ { q }_{ i } } \ge \frac { { w }_{ j } }{ { q }_{ j } } (j\neq i)</script><p>所以$i$号人的$\frac { w }{ q } $应该是最大的。 所以只需要对$\frac { w }{ q } $进行排序，然后计算前$i$个人中，最小的K个quality的和就行了，优先队列或者大根堆维护即可。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostToHireWorkers</span><span class="params">(self, quality, wage, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type quality: List[int]</span></span><br><span class="line"><span class="string">        :type wage: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = [(w/q, w, q) <span class="keyword">for</span> (w, q) <span class="keyword">in</span> zip(wage, quality)]</span><br><span class="line">        a.sort()</span><br><span class="line">        <span class="keyword">import</span> queue <span class="keyword">as</span> Q</span><br><span class="line">        q = Q.PriorityQueue()</span><br><span class="line">        ans = <span class="number">-1</span></span><br><span class="line">        tot = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">            <span class="keyword">if</span>(q.qsize() &gt;= K):</span><br><span class="line">                tot -= -q.get_nowait()</span><br><span class="line">            tot += a[i][<span class="number">2</span>]</span><br><span class="line">            q.put(-a[i][<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">if</span>(q.qsize() &gt;= K <span class="keyword">and</span> (tot*a[i][<span class="number">0</span>]&lt;ans <span class="keyword">or</span> ans==<span class="number">-1</span>)):</span><br><span class="line">                ans = tot*a[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Computer Graphics Final Project Simple RayTracing</title>
      <link href="/2017/06/12/computer-graphics-final-project-simple-raytracing/"/>
      <url>/2017/06/12/computer-graphics-final-project-simple-raytracing/</url>
      
        <content type="html"><![CDATA[<p>最后一个实验要求做一个RayTracing的小东西，本实验采用了Cornell Box作为模型，实现了简单的tracer。 主要从以下几个方面简单的介绍一下：</p><a id="more"></a><h1 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h1><img src="/2017/06/12/computer-graphics-final-project-simple-raytracing/tracing.png"><p> 算法伪代码如上，即对每个像素点随机选取光线方向，如果击中点的话对其进行render，并根据反射、折射等递归计算，没有击中点则返回背景颜色。</p><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><p>在实验的过程中，调用glm后发现实际的速度并没有快很多，反而各种方法比较凌乱，因此自己实现了一个Vector的struct：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Calc.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y, z;          </span><br><span class="line">Vec(<span class="keyword">double</span> x_ = <span class="number">0</span>, <span class="keyword">double</span> y_ = <span class="number">0</span>, <span class="keyword">double</span> z_ = <span class="number">0</span>) &#123; </span><br><span class="line">x = x_; y = y_; z = z_; </span><br><span class="line">&#125;</span><br><span class="line">Vec <span class="keyword">operator</span>+(<span class="keyword">const</span> Vec &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Vec(x + b.x, y + b.y, z + b.z); </span><br><span class="line">&#125;</span><br><span class="line">Vec <span class="keyword">operator</span>-(<span class="keyword">const</span> Vec &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Vec(x - b.x, y - b.y, z - b.z); </span><br><span class="line">&#125;</span><br><span class="line">Vec <span class="keyword">operator</span>*(<span class="keyword">double</span> b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Vec(x*b, y*b, z*b); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Vec <span class="title">mult</span><span class="params">(<span class="keyword">const</span> Vec &amp;b)</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> Vec(x*b.x, y*b.y, z*b.z); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Vec&amp; <span class="title">norm</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * (<span class="number">1</span> / Qsqrt(x*x + y*y + z*z)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Vec &amp;b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*b.x + y*b.y + z*b.z; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function">Vec <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Vec &amp;rhs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Vec(y * rhs.z - z * rhs.y,</span><br><span class="line">z * rhs.x - x * rhs.z,</span><br><span class="line">x * rhs.y - y * rhs.x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里面有个叫做Qsqrt的东西，其实是鼎鼎有名的卡马克常数的那个平方根快速算法，具体解释我可能有时间再写一篇博客探讨下： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Qsqrt</span><span class="params">(<span class="keyword">float</span> number)</span><span class="comment">//By Carmark</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">float</span> x2, y;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> threehalfs = <span class="number">1.5F</span>;</span><br><span class="line">x2 = number * <span class="number">0.5F</span>;</span><br><span class="line">y = number;</span><br><span class="line">i = *(<span class="keyword">int</span> *)&amp;y;</span><br><span class="line">i = <span class="number">0x5f375a86</span> - (i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">y = *(<span class="keyword">float</span> *)&amp;i;</span><br><span class="line">y = y * (threehalfs - (x2 * y * y));</span><br><span class="line">y = y * (threehalfs - (x2 * y * y));</span><br><span class="line">y = y * (threehalfs - (x2 * y * y));</span><br><span class="line"><span class="keyword">return</span> number*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h1><p>光线类，o和d分别表示起始位置和方向<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Vecter.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ray</span> &#123;</span> Vec o, d; Ray(Vec o_, Vec d_) : o(o_), d(d_) &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure></p><h1 id="球"><a href="#球" class="headerlink" title="球"></a>球</h1><p>之后写了一个叫做Sphere的类，材质包括漫反射、反射与折射，并实现一下与光线相交的函数，返回光线的参数方程（o+td）中第一个交点的t： </p><img src="/2017/06/12/computer-graphics-final-project-simple-raytracing/sphereinter.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Ray.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Calc.h"</span></span></span><br><span class="line"><span class="keyword">enum</span> Refl_t &#123; DIFF, SPEC, REFR &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sphere</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> rad;       </span><br><span class="line">Vec p, e, c;<span class="comment">// position, emission, color;</span></span><br><span class="line">Refl_t refl;</span><br><span class="line">Sphere(<span class="keyword">double</span> rad_, Vec p_, Vec e_, Vec c_, Refl_t refl_) :</span><br><span class="line">rad(rad_), p(p_), e(e_), c(c_), refl(refl_) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">intersect</span><span class="params">(<span class="keyword">const</span> Ray &amp;r)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// returns distance, 0 if nohit </span></span><br><span class="line">Vec op = p - r.o; </span><br><span class="line"><span class="keyword">double</span> t, eps = <span class="number">1e-4</span>, b = op.dot(r.d), det = b*b - op.dot(op) + rad*rad;</span><br><span class="line"><span class="keyword">if</span> (det&lt;<span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">det = Qsqrt(det);</span><br><span class="line"><span class="keyword">return</span> (t = b - det)&gt;eps ? t : ((t = b + det)&gt;eps ? t : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="场景构建"><a href="#场景构建" class="headerlink" title="场景构建"></a>场景构建</h1><p>由于当半径很大的时候，球的部分表面可以被看做是平面，因此不必单独写平面的类，直接调用sphere就好。 下面的代码设置了上下左右前后六个表面、灯光和材质分别是反射和折射的两个球： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sphere spheres[] = &#123;<span class="comment">//Scene: radius, position, emission, color, material </span></span><br><span class="line">Sphere(<span class="number">1e5</span>, Vec(<span class="number">1e5</span> + <span class="number">1</span>,<span class="number">40.8</span>,<span class="number">81.6</span>), Vec(),Vec(<span class="number">.75</span>,<span class="number">.25</span>,<span class="number">.25</span>),DIFF),<span class="comment">//Left </span></span><br><span class="line">Sphere(<span class="number">1e5</span>, Vec(<span class="number">-1e5</span> + <span class="number">99</span>,<span class="number">40.8</span>,<span class="number">81.6</span>),Vec(),Vec(<span class="number">.25</span>,<span class="number">.25</span>,<span class="number">.75</span>),DIFF),<span class="comment">//Rght </span></span><br><span class="line">Sphere(<span class="number">1e5</span>, Vec(<span class="number">50</span>,<span class="number">40.8</span>, <span class="number">1e5</span>),     Vec(),Vec(<span class="number">.75</span>,<span class="number">.75</span>,<span class="number">.75</span>),DIFF),<span class="comment">//Back </span></span><br><span class="line">Sphere(<span class="number">1e5</span>, Vec(<span class="number">50</span>,<span class="number">40.8</span>,<span class="number">-1e5</span> + <span class="number">170</span>), Vec(),Vec(),           DIFF),<span class="comment">//Frnt </span></span><br><span class="line">Sphere(<span class="number">1e5</span>, Vec(<span class="number">50</span>, <span class="number">1e5</span>, <span class="number">81.6</span>),    Vec(),Vec(<span class="number">.75</span>,<span class="number">.75</span>,<span class="number">.75</span>),DIFF),<span class="comment">//Botm </span></span><br><span class="line">Sphere(<span class="number">1e5</span>, Vec(<span class="number">50</span>,<span class="number">-1e5</span> + <span class="number">81.6</span>,<span class="number">81.6</span>),Vec(),Vec(<span class="number">.75</span>,<span class="number">.75</span>,<span class="number">.75</span>),DIFF),<span class="comment">//Top </span></span><br><span class="line">Sphere(<span class="number">16.5</span>,Vec(<span class="number">27</span>,<span class="number">16.5</span>,<span class="number">47</span>),       Vec(),Vec(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)*<span class="number">.999</span>, SPEC),<span class="comment">//Mirr </span></span><br><span class="line">Sphere(<span class="number">16.5</span>,Vec(<span class="number">73</span>,<span class="number">16.5</span>,<span class="number">78</span>),       Vec(),Vec(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)*<span class="number">.999</span>, REFR),<span class="comment">//Glas </span></span><br><span class="line">Sphere(<span class="number">600</span>, Vec(<span class="number">50</span>,<span class="number">681.6</span> - <span class="number">.27</span>,<span class="number">81.6</span>),Vec(<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>),  Vec(), DIFF) <span class="comment">//Lite </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="图像、采样率、摄像机的设置"><a href="#图像、采样率、摄像机的设置" class="headerlink" title="图像、采样率、摄像机的设置"></a>图像、采样率、摄像机的设置</h1><p>设置一些基本的图像参数，用于进一步的构建图像：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> w = <span class="number">1024</span>, h = <span class="number">768</span>, samps = <span class="number">1</span>; </span><br><span class="line"><span class="function">Ray <span class="title">cam</span><span class="params">(Vec(<span class="number">50</span>, <span class="number">52</span>, <span class="number">295.6</span>), Vec(<span class="number">0</span>, <span class="number">-0.042612</span>, <span class="number">-1</span>).norm())</span></span>; <span class="comment">// camera position direction</span></span><br><span class="line">Vec cx = Vec(w*<span class="number">.5135</span> / h), cy = (cx.cross(cam.d)).norm()*<span class="number">.5135</span>, r, *c = <span class="keyword">new</span> Vec[w*h];</span><br></pre></td></tr></table></figure></p><h1 id="循环处理像素点"><a href="#循环处理像素点" class="headerlink" title="循环处理像素点"></a>循环处理像素点</h1><p>对于每个像素点，选取它的四邻域进行随机取样，取样的个数就是采样率的samps：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y&amp;lt;h; y++) &#123;                       <span class="comment">// Rows</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\rRendering (%d spp) %5.2f%%"</span>, samps * <span class="number">4</span>, <span class="number">100.</span>*y / (h - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">short</span> x = <span class="number">0</span>; x&amp;lt;w; x++)   <span class="comment">// Cols </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sy = <span class="number">0</span>, i = (h - y - <span class="number">1</span>)*w + x; sy&amp;lt;<span class="number">2</span>; sy++)     </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sx = <span class="number">0</span>; sx&amp;lt;<span class="number">2</span>; sx++, r = Vec()) &#123;        <span class="comment">// 2x2 subpixel cols </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s&amp;lt;samps; s++) &#123;<span class="comment">//samples</span></span><br><span class="line"><span class="keyword">double</span> r1 = <span class="number">2</span> * random(), dx = r1&amp;lt;<span class="number">1</span> ? <span class="built_in">sqrt</span>(r1) - <span class="number">1</span> : <span class="number">1</span> - <span class="built_in">sqrt</span>(<span class="number">2</span> - r1);</span><br><span class="line"><span class="keyword">double</span> r2 = <span class="number">2</span> * random(), dy = r2&amp;lt;<span class="number">1</span> ? <span class="built_in">sqrt</span>(r2) - <span class="number">1</span> : <span class="number">1</span> - <span class="built_in">sqrt</span>(<span class="number">2</span> - r2);</span><br><span class="line">Vec d = cx*(((sx + <span class="number">.5</span> + dx) / <span class="number">2</span> + x) / w - <span class="number">.5</span>) + cy*(((sy + <span class="number">.5</span> + dy) / <span class="number">2</span> + y) / h - <span class="number">.5</span>) + cam.d;</span><br><span class="line">r = r + radiance(Ray(cam.o + d * <span class="number">140</span>, d.norm()), <span class="number">0</span>)*(<span class="number">1.</span> / samps);</span><br><span class="line">&#125; </span><br><span class="line">c[i] = c[i] + Vec(clamp(r.x), clamp(r.y), clamp(r.z))*<span class="number">.25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，radiance就是进行raycast的递归过程，计算之后对各个采样点计算得来的颜色取平均值。  </p><h1 id="RayCast过程"><a href="#RayCast过程" class="headerlink" title="RayCast过程"></a>RayCast过程</h1><p>即radiance过程，是一个递归的过程，首先intersect方法得到这个光线击中的物体： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">intersect</span><span class="params">(<span class="keyword">const</span> Ray &amp;r, <span class="keyword">double</span> &amp;t, <span class="keyword">int</span> &amp;id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> n = <span class="keyword">sizeof</span>(spheres) / <span class="keyword">sizeof</span>(Sphere), d, inf = t = <span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">int</span>(n); i--;) </span><br><span class="line"><span class="keyword">if</span> ((d = spheres[i].intersect(r)) &amp;&amp; d&lt;t) &#123;</span><br><span class="line">t = d; id = i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t&lt;inf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置了递归的深度是5，得到击中的物体后计算法向量（和背面剔除后的法向量），如果递归超过深度则按照概率衰减或直接返回强度（灯光）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> t;                               </span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;                               </span><br><span class="line"><span class="keyword">if</span> (!intersect(r, t, id)) </span><br><span class="line"><span class="keyword">return</span> Vec();  </span><br><span class="line"><span class="keyword">const</span> Sphere &amp;obj = spheres[id];        </span><br><span class="line">Vec x = r.o + r.d*t, n = (x - obj.p).norm(), nl = n.dot(r.d)&lt;<span class="number">0</span> ? n : n*<span class="number">-1</span>, f = obj.c;<span class="comment">//n:normal nl:backface culling normal</span></span><br><span class="line"><span class="keyword">double</span> p = f.x&gt;f.y &amp;&amp; f.x&gt;f.z ? f.x : f.y&gt;f.z ? f.y : f.z; <span class="comment">// p:max refl</span></span><br><span class="line"><span class="keyword">if</span> (++depth&gt;<span class="number">5</span>) </span><br><span class="line"><span class="keyword">if</span> (random()&lt;p) </span><br><span class="line">f = f*(<span class="number">1</span> / p); </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> obj.e;</span><br></pre></td></tr></table></figure></p><p>之后是漫反射、镜面反射的着色过程，在<a href="">之前的博客</a>中有提及，这里不再赘述计算过程。需要注意的是，漫反射之后的来源光线是随机选取的，随机的过程可以用下图表示。<br><img src="/2017/06/12/computer-graphics-final-project-simple-raytracing/hemisphere.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj.refl == DIFF) &#123; </span><br><span class="line"><span class="keyword">double</span> r1 = <span class="number">2</span> * M_PI*random(), r2 = random(), r2s = <span class="built_in">sqrt</span>(r2);</span><br><span class="line">Vec w = nl, u = ((<span class="built_in">fabs</span>(w.x)&gt;<span class="number">.1</span> ? Vec(<span class="number">0</span>, <span class="number">1</span>) : Vec(<span class="number">1</span>)).cross(w)).norm(), v = w.cross(u);</span><br><span class="line">Vec d = (u*<span class="built_in">cos</span>(r1)*r2s + v*<span class="built_in">sin</span>(r1)*r2s + w*<span class="built_in">sqrt</span>(<span class="number">1</span> - r2)).norm();</span><br><span class="line"><span class="keyword">return</span> obj.e + f.mult(radiance(Ray(x, d), depth));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (obj.refl == SPEC)</span><br><span class="line"><span class="keyword">return</span> obj.e + f.mult(radiance(Ray(x, r.d - n * <span class="number">2</span> * n.dot(r.d)), depth))</span><br></pre></td></tr></table></figure><p>之后是折射与反射的判断关系……首先要复习一下全反射（Total internal reflection ）的相关知识，判断一下是需要进行全反射就好还是需要进一步计算折射：</p><img src="/2017/06/12/computer-graphics-final-project-simple-raytracing/totalreflect.png"><p> 如果有折射，用下面这张图中的公式计算：<br><img src="/2017/06/12/computer-graphics-final-project-simple-raytracing/refract.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Ray <span class="title">reflRay</span><span class="params">(x, r.d - n * <span class="number">2</span> * n.dot(r.d))</span></span>;     <span class="comment">// Ideal dielectric REFRACTION </span></span><br><span class="line"><span class="keyword">bool</span> into = n.dot(nl)&gt;<span class="number">0</span>;                <span class="comment">// Ray from outside going in? </span></span><br><span class="line"><span class="keyword">double</span> nc = <span class="number">1</span>, nt = <span class="number">1.5</span>, nnt = into ? nc / nt : nt / nc, ddn = r.d.dot(nl), cos2t;</span><br><span class="line"><span class="keyword">if</span> ((cos2t = <span class="number">1</span> - nnt*nnt*(<span class="number">1</span> - ddn*ddn))&lt;<span class="number">0</span>)    <span class="comment">// Total internal reflection </span></span><br><span class="line"><span class="keyword">return</span> obj.e + f.mult(radiance(reflRay, depth));</span><br><span class="line">Vec tdir = (r.d*nnt - n*((into ? <span class="number">1</span> : <span class="number">-1</span>)*(ddn*nnt + <span class="built_in">sqrt</span>(cos2t)))).norm();</span><br><span class="line"><span class="keyword">double</span> a = nt - nc, b = nt + nc, R0 = a*a / (b*b), c = <span class="number">1</span> - (into ? -ddn : tdir.dot(n));</span><br><span class="line"><span class="keyword">double</span> Re = R0 + (<span class="number">1</span> - R0)*c*c*c*c*c, Tr = <span class="number">1</span> - Re, P = <span class="number">.25</span> + <span class="number">.5</span>*Re, RP = Re / P, TP = Tr / (<span class="number">1</span> - P);</span><br><span class="line"><span class="keyword">return</span> obj.e + f.mult(depth&gt;<span class="number">2</span> ? (random()&lt;P ?   <span class="comment">// Russian roulette </span></span><br><span class="line">radiance(reflRay, depth)*RP : radiance(Ray(x, tdir), depth)*TP) :</span><br><span class="line">radiance(reflRay, depth)*Re + radiance(Ray(x, tdir), depth)*Tr);</span><br></pre></td></tr></table></figure><h1 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h1><p>输出ppm图像如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE *f;</span><br><span class="line"><span class="keyword">errno_t</span> err;</span><br><span class="line">err = fopen_s(&amp;f, <span class="string">"image.ppm"</span>, <span class="string">"w"</span>); </span><br><span class="line"><span class="built_in">fprintf</span>(f, <span class="string">"P3\n%d %d\n%d\n"</span>, w, h, <span class="number">255</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;w*h; i++)</span><br><span class="line"><span class="built_in">fprintf</span>(f, <span class="string">"%d %d %d "</span>, toInt(c[i].x), toInt(c[i].y), toInt(c[i].z));</span><br></pre></td></tr></table></figure></p><p>采样率低的时候噪点很多，随着采样率升高效果逐渐平滑和稳定：<br><img src="/2017/06/12/computer-graphics-final-project-simple-raytracing/48ssp-1024x768.jpg"><br><img src="/2017/06/12/computer-graphics-final-project-simple-raytracing/500-1024x768.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Computer Graphics Experiment III Part.2 LightModel in OpenGL (Inplemented via GLSL)</title>
      <link href="/2017/05/22/computer-graphics-experiment-iii-part-2-lightmodel-in-opengl-inplemented-via-glsl/"/>
      <url>/2017/05/22/computer-graphics-experiment-iii-part-2-lightmodel-in-opengl-inplemented-via-glsl/</url>
      
        <content type="html"><![CDATA[<p>图形学实验三第二部分——GLSL实现的三种光照模型。 此次试验用GLSL（OpenGL Shading Language）着色语言实现OpenGL自带的光照模型，比较不同的着色方法带来的不同。<br><a id="more"></a></p><h1 id="点的着色过程"><a href="#点的着色过程" class="headerlink" title="点的着色过程"></a>点的着色过程</h1><p>首先，对某个点的计算光照的方法如下:</p><h2 id="环境光-Ambient-与漫反射-Diffuse"><a href="#环境光-Ambient-与漫反射-Diffuse" class="headerlink" title="环境光(Ambient)与漫反射(Diffuse)"></a>环境光(Ambient)与漫反射(Diffuse)</h2><img src="/2017/05/22/computer-graphics-experiment-iii-part-2-lightmodel-in-opengl-inplemented-via-glsl/ambientdiff-1024x335.png"><p>即环境光直接是环境光，漫反射经过反射（由于是单位向量直接取内积）后反射到所有方向。 其中$k$是衰减因子，在实验中忽略了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ambient</span></span><br><span class="line"><span class="keyword">float</span> ambientStrength = <span class="number">0.1f</span>;</span><br><span class="line">vec3 ambient = ambientStrength * lightColor;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Diffuse </span></span><br><span class="line">vec3 norm = normalize(Normal);</span><br><span class="line">vec3 lightDir = normalize(lightPos - FragPos);</span><br><span class="line"><span class="keyword">float</span> diff = max(dot(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">vec3 diffuse = diff * lightColor;</span><br></pre></td></tr></table></figure></p><h2 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h2><img src="/2017/05/22/computer-graphics-experiment-iii-part-2-lightmodel-in-opengl-inplemented-via-glsl/spec-1024x631.png"><p>如图，镜面反射需要先计算反射光的方向，再乘以与视线向量的夹角的余弦值，其中余弦值以高光系数$n_{shiny}$作幂次。 反射光$R$的方向可以由下图求得</p><img src="/2017/05/22/computer-graphics-experiment-iii-part-2-lightmodel-in-opengl-inplemented-via-glsl/relect-1024x585.png"><p>也可以直接在GLSL中调用relect()函数，该函数接收入射光方向和法向量，返回反射后的光线方向：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Specular</span></span><br><span class="line"><span class="keyword">float</span> specularStrength = <span class="number">0.5f</span>;</span><br><span class="line">vec3 viewDir = normalize(viewPos - FragPos);</span><br><span class="line">vec3 reflectDir = reflect(-lightDir, norm);  </span><br><span class="line"><span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line">vec3 specular = specularStrength * spec * lightColor;</span><br></pre></td></tr></table></figure></p><h1 id="Gouraud着色"><a href="#Gouraud着色" class="headerlink" title="Gouraud着色"></a>Gouraud着色</h1><p>Gouraud着色为只对三角面片的顶点计算着色，其他的点通过插值计算颜色，GLSL中的顶点和片段着色器分别如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gouraudShader.vs</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line"></span><br><span class="line">out vec3 LightingColor; <span class="comment">// resulting color from lighting calculations</span></span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line">uniform vec3 lightColor;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * vec4(position, <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// gouraud shading</span></span><br><span class="line">    <span class="comment">// ------------------------</span></span><br><span class="line">    vec3 Position = vec3(model * vec4(position, <span class="number">1.0</span>));</span><br><span class="line">    vec3 Normal = mat3(transpose(inverse(model))) * normal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    <span class="keyword">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line">    vec3 ambient = ambientStrength * lightColor;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// diffuse </span></span><br><span class="line">    vec3 norm = normalize(Normal);</span><br><span class="line">    vec3 lightDir = normalize(lightPos - Position);</span><br><span class="line">    <span class="keyword">float</span> diff = max(dot(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    <span class="keyword">float</span> specularStrength = <span class="number">1.0</span>; <span class="comment">// this is set higher to better show the effect of Gouraud shading </span></span><br><span class="line">    vec3 viewDir = normalize(viewPos - Position);</span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, norm);  </span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line">    vec3 specular = specularStrength * spec * lightColor;      </span><br><span class="line"></span><br><span class="line">    LightingColor = ambient + diffuse + specular;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>顶点着色器计算之后传入片段着色器后会自动对顶点着色器的输出进行插值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gouraudShader.frag</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 LightingColor; </span><br><span class="line"></span><br><span class="line">uniform vec3 objectColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FragColor = vec4(LightingColor * objectColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果演示如下，可以看出明显的区域和插值结果：<br><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"/2017/05/22/computer-graphics-experiment-iii-part-2-lightmodel-in-opengl-inplemented-via-glsl/GouraudShading.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></p><h1 id="Phong着色"><a href="#Phong着色" class="headerlink" title="Phong着色"></a>Phong着色</h1><p>和Gouraud着色不同，Phong着色则是对法向量进行插值，之后对每个点计算光照，因此，光照的计算是在片段着色器中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PhongShader.vs</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line"></span><br><span class="line">out vec3 Normal;</span><br><span class="line">out vec3 FragPos;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view *  model * vec4(position, <span class="number">1.0f</span>);</span><br><span class="line">    FragPos = vec3(model * vec4(position, <span class="number">1.0f</span>));</span><br><span class="line">    Normal = mat3(transpose(inverse(model))) * normal;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PhongShader.frag</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line">in vec3 FragPos;  </span><br><span class="line">in vec3 Normal;  </span><br><span class="line">  </span><br><span class="line">uniform vec3 lightPos; </span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line">uniform vec3 lightColor;</span><br><span class="line">uniform vec3 objectColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Ambient</span></span><br><span class="line">    <span class="keyword">float</span> ambientStrength = <span class="number">0.1f</span>;</span><br><span class="line">    vec3 ambient = ambientStrength * lightColor;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Diffuse </span></span><br><span class="line">    vec3 norm = normalize(Normal);</span><br><span class="line">    vec3 lightDir = normalize(lightPos - FragPos);</span><br><span class="line">    <span class="keyword">float</span> diff = max(dot(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Specular</span></span><br><span class="line">    <span class="keyword">float</span> specularStrength = <span class="number">0.5f</span>;</span><br><span class="line">    vec3 viewDir = normalize(viewPos - FragPos);</span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, norm);  </span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line">    vec3 specular = specularStrength * spec * lightColor;  </span><br><span class="line">        </span><br><span class="line">    vec3 result = (ambient + diffuse + specular) * objectColor;</span><br><span class="line">    color = vec4(result, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是最好的：<br><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"video":{"url":"/2017/05/22/computer-graphics-experiment-iii-part-2-lightmodel-in-opengl-inplemented-via-glsl/PhongShading.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></p><h1 id="Flat着色"><a href="#Flat着色" class="headerlink" title="Flat着色"></a>Flat着色</h1><p>Flat就比较Naive了，每一个三角面片只计算一个光照，并将这个光照当做这个三角面片的光照：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FlatShader.vs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 position;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 normal;</span><br><span class="line"></span><br><span class="line">flat out vec3 LightingColor;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line">uniform vec3 lightColor;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * vec4(position, <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// flat shading</span></span><br><span class="line">    <span class="comment">// ------------------------</span></span><br><span class="line">    vec3 Position = vec3(model * vec4(position, <span class="number">1.0</span>));</span><br><span class="line">    vec3 Normal = mat3(transpose(inverse(model))) * normal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    <span class="keyword">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line">    vec3 ambient = ambientStrength * lightColor;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// diffuse </span></span><br><span class="line">    vec3 norm = normalize(Normal);</span><br><span class="line">    vec3 lightDir = normalize(lightPos - Position);</span><br><span class="line">    <span class="keyword">float</span> diff = max(dot(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    <span class="keyword">float</span> specularStrength = <span class="number">1.0</span>;</span><br><span class="line">    vec3 viewDir = normalize(viewPos - Position);</span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, norm);  </span><br><span class="line">    <span class="keyword">float</span> spec = <span class="built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line">    vec3 specular = specularStrength * spec * lightColor;      </span><br><span class="line"></span><br><span class="line">    LightingColor = ambient + diffuse + specular;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FlatShader.frag</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">flat in vec3 LightingColor;</span><br><span class="line">layout( location = <span class="number">0</span> ) out vec4 FragColor;</span><br><span class="line">uniform vec3 objectColor;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FragColor = vec4(LightingColor * objectColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果有明显的马赫带（x<br><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"video":{"url":"/2017/05/22/computer-graphics-experiment-iii-part-2-lightmodel-in-opengl-inplemented-via-glsl/FlatShading.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></p><h1 id="三种着色方法比较"><a href="#三种着色方法比较" class="headerlink" title="三种着色方法比较"></a>三种着色方法比较</h1><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"video":{"url":"/2017/05/22/computer-graphics-experiment-iii-part-2-lightmodel-in-opengl-inplemented-via-glsl/AllTogether.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Computer Graphics Experiment III Part.1 LightModel in OpenGL (based on WalkingMan)</title>
      <link href="/2017/04/20/computer-graphics-experiment-iii-part-1-lightmodel-in-opengl-based-on-walkingman/"/>
      <url>/2017/04/20/computer-graphics-experiment-iii-part-1-lightmodel-in-opengl-based-on-walkingman/</url>
      
        <content type="html"><![CDATA[<p>图形学实验三第一部分——实验二基础上的光照模型。 此次试验首先在上一个实验的基础上实现OpenGL自带的光照模型，比较不同的着色方法带来的不同，之后再通过GLSL写着色器实现两种不同的光照模型。 本篇博客首先在上一个实验：<a href="">WalkMan</a> 的基础上添加光照，并使用两种不同的着色方法。<br><a id="more"></a></p><h2 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h2><p>OpenGL中的光照模型中的反射光分为三个分量，分别是环境反射光（Ambient Light）、漫反射光（Diffuse Light）和镜面反射光（Specular Light）。</p><ul><li><p>环境光Ambient：是由光源发出经环境多次散射而无法确定其入射方向的光，即似乎来自所有方向。其特征是入射方向和出射方向均为任意方向。</p></li><li><p>漫射光Diffuse：来自特定方向，它垂直于物体时比倾斜时更明亮。一旦它照射到物体上，则在各个方向上均匀地发散出去，效果为无论视点在哪里它都一样亮，其特征是入射方向唯一、出射方向为任意方向。</p></li><li><p>镜面光Specular：来自特定方向并沿另一方向反射出去，一个平行激光束在高质量的镜面上产生100%的镜面反射，其特征是入射方向和出射方向均唯一。</p></li></ul><h2 id="创建光源"><a href="#创建光源" class="headerlink" title="创建光源"></a><strong>创建光源</strong></h2><p>OpenGL中用函数glLightfv来创建光源，函数原型是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glLightfv</span> <span class="params">(GLenum light, GLenum pname, <span class="keyword">const</span> GLfloat *params)</span></span></span><br></pre></td></tr></table></figure></p><p>第一个参数light指定所创建的光源号，如GL_LIGHT0、GL_LIGHT1、…、GL_LIGHT7。 第二个参数pname指定光源特性，这个参数的具体信息见下表所示。 <img src="/2017/04/20/computer-graphics-experiment-iii-part-1-lightmodel-in-opengl-based-on-walkingman/pname.png"> 第三个参数设置相应的光源特性值。 如下，我们便可以定义一个位置在(5,5,5)没有环境光，镜面反射光和漫反射光都为白光的光源<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GLfloat light_ambient[] = &#123; <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">GLfloat light_diffuse[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">GLfloat light_specular[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line">GLfloat light_position[] = &#123; <span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">0</span> &#125;;</span><br><span class="line">glLightfv(GL_LIGHT0, GL_POSITION, light_position);</span><br><span class="line">glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);</span><br><span class="line">glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);</span><br><span class="line">glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);</span><br></pre></td></tr></table></figure></p><p>其中，position是其次坐标系，当第四个参数为0时，表示点光源，为1时表示由前三个数组成向量射来的平型光源。</p><h2 id="Phong-Model与Flat-Model"><a href="#Phong-Model与Flat-Model" class="headerlink" title="Phong Model与Flat Model"></a>Phong Model与Flat Model</h2><p>我们用下列代码控制关照的模式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!smooth)</span><br><span class="line">glShadeModel(GL_FLAT);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">glShadeModel(GL_SMOOTH);</span><br></pre></td></tr></table></figure></p><p>然后光照模型的对比如下： <img src="/2017/04/20/computer-graphics-experiment-iii-part-1-lightmodel-in-opengl-based-on-walkingman/smooth.png"> <img src="/2017/04/20/computer-graphics-experiment-iii-part-1-lightmodel-in-opengl-based-on-walkingman/flat.png"> 可见，FLAT模式下出现了明显的马赫带。 新版本的OpenGL提供了更加自由的渲染模式，我们在<a href="">下一篇博客</a>中将利用其通过不同的Model渲染新的场景。</p>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>About the forum with Mr. Coordinate Song</title>
      <link href="/2017/04/18/about-the-forum-with-mr-coordinate-song/"/>
      <url>/2017/04/18/about-the-forum-with-mr-coordinate-song/</url>
      
        <content type="html"><![CDATA[<p>下面对前几天去青岛和学校学生工作部的副部长宋部长（Coordinate Song）座谈会的笔记简单整理下，跟大家汇报下工作： 座谈会邀请了本科和研究生（博士生）各10人左右，所谈内容有关于本科生的，主要是搬迁至青岛校区后的学习、生活、发展三个问题，本文记录也先暂时按照这三个方面对青岛校区的各项方面和本次座谈会的内容做一下简短的介绍：<br><a id="more"></a></p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="校区建设情况（虽然基本啥都没建好）"><a href="#校区建设情况（虽然基本啥都没建好）" class="headerlink" title="校区建设情况（虽然基本啥都没建好）"></a>校区建设情况（虽然基本啥都没建好）</h3><p>先看下规划图 <img src="/2017/04/18/about-the-forum-with-mr-coordinate-song/guihua.jpg"> 然后目前已经启用（并没）的一期工程是红色圈出来的区域<img src="/2017/04/18/about-the-forum-with-mr-coordinate-song/yiqi.jpg"> 根据我的会议笔记，大体上目前的进度如下：</p><ul><li>图书馆（10月份竣工）： 国内最大【</li><li>青岛政府代建: 体育馆（风雨操场）：未动工 博物馆：</li><li>创新实验室： 应该会都予以保留</li><li>餐厅： 目前开放了一层，将来三层（</li><li>综合服务楼： 原计划十月份竣工（</li><li>轻轨： 年底通车</li></ul><h3 id="生活硬件设施"><a href="#生活硬件设施" class="headerlink" title="生活硬件设施"></a>生活硬件设施</h3><p>宿舍条件还是不错的，照片就不放了，想看去群相册里可以看到，主要包括</p><ul><li>形体训练室（ww： 女生宿舍才有</li><li>自助厨房： 不允许用油，可以烤、蒸、煮 不允许明火 不提倡做正餐</li><li>直饮水： 直饮水机蛮多的，基本不用拿暖瓶</li><li>洗衣房： 6-8kg ￥3  熨烫机 洗鞋机（</li><li>宿舍卫生： 要会刷马桶（……），大概是因为是独立卫浴什么的吧</li><li>独立卫浴： 有</li><li>空调： 空调？不需要的（据说有需要再加</li></ul><h3 id="学校周边"><a href="#学校周边" class="headerlink" title="学校周边"></a>学校周边</h3><ul><li>东里村：（不是来搞笑的 商场啥的（因为学校的商场（综合服务楼）还没建好</li><li>东边的海水浴场： 不建议去游泳，暗流涌动易伤人（</li><li>港中旅： 这个看起来很6，宋部长好像没说，反正我去不起（x</li><li>别的没了</li></ul><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>学习方面本科生采用书院制，个人认为就是把不同学院搞成一起玩的一个管理模式，淡化学院制的培养模式，下面是我的笔记，大家看看就好……</p><ol><li>师生关系：导师培养制度 一个导师最多十个本科生 辅导员也在宿舍楼内办公</li><li>同学关系： 不同学院的同学间交流 淡化学院间同学隔阂 基本没有学院单独的学生组织（ 男女生有序交流（宿舍同层开个门就可能看到啥的）， 交流室 书院提供的服务设施 通识教育 宿舍不同学院【好辣鸡啊【目前并没实行 监督管理由学生负责： 学生会、自我管理委员会、自我监督委员会（纪委喵喵喵？（达康书记！</li></ol><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>开会没说，我们提了诸如语言考试考点、校招等等问题和意见后他表示嗯嗯很有道理这些都是需要解决的问题（(╯‵□′)╯︵┻━┻</p><h2 id="搬迁"><a href="#搬迁" class="headerlink" title="搬迁"></a>搬迁</h2><ol><li>搬迁人员信息 前些天统计的信息是用来录入数据库、然后大家自选床位房间用的，基本是自己去网上选择房间床位，辅导员协助。 这样可能存在六人间变成四人间的各种去留问题，大概是需要大家协商或辅导员协助叭（</li><li>时间安排 7.10开始搬迁，三天的时间完成</li><li>具体实施方案<ul><li>人和东西分开搬：7.10东西来人不来，东西会放到选好的床位上，人九月份才能来（也就是提前来了也不能住（也就是辣鸡到不行（济南青岛无一处容身之地（可能会在济南保留有需要的同学的床位的吧（不知</li><li>每人给1~2条邮政保密袋，建议把不适合长途运的东西都处理掉或人工搬，没有搬迁补助</li></ul></li><li>搬迁手册 搬迁手册里应该有具体的实施方案，做好后会发给大家（</li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>宋部长要统计关于搬迁的问题，写了个<a href="https://wj.qq.com/s/1286128/3b52/" target="_blank" rel="noopener">表单</a>大家可以去填（表单不是官方的（只是统计下（当然也不一定只提关于搬迁的问题，刚才说的生活学习发展的问题都能提 填的问题可以提前在班群里询问下，如果我能解答尽量给大家解答</p>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Computer Graphics Experiment II Part.2 3D Boxman</title>
      <link href="/2017/04/05/computer-graphics-experiment-ii-part-2-3d-boxman/"/>
      <url>/2017/04/05/computer-graphics-experiment-ii-part-2-3d-boxman/</url>
      
        <content type="html"><![CDATA[<p>图形学实验二第二部分——智障的3D小人 demo以及相机相关请看上一篇博文——<a href="">3D Touring</a><br><a id="more"></a></p><h2 id="绘图基本函数"><a href="#绘图基本函数" class="headerlink" title="绘图基本函数"></a>绘图基本函数</h2><p>首先要实现个画正方体和长方体的函数，正方体是直接画六个面，长方体则是更改了scale后的画正方体。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawCube</span><span class="params">(<span class="keyword">double</span> xPos, <span class="keyword">double</span> yPos, <span class="keyword">double</span> zPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">glPushMatrix();</span><br><span class="line">glTranslated(xPos, yPos, zPos);</span><br><span class="line">glBegin(GL_POLYGON);</span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);  <span class="comment">//顶面</span></span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);  <span class="comment">//正面</span></span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);  <span class="comment">//右面</span></span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>); <span class="comment">//左面</span></span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>);  <span class="comment">//底面</span></span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);  <span class="comment">//背面</span></span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glVertex3d(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glEnd();</span><br><span class="line">glPopMatrix();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawBox</span><span class="params">(<span class="keyword">double</span> xPos, <span class="keyword">double</span> yPos, <span class="keyword">double</span> zPos, <span class="keyword">double</span> xLen, <span class="keyword">double</span> yLen, <span class="keyword">double</span> zLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">glPushMatrix();</span><br><span class="line">glTranslated(xPos, yPos, zPos);</span><br><span class="line">glScaled(xLen, yLen, zLen); </span><br><span class="line">drawCube(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">glPopMatrix();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后画小人所需要用到的绘图函数基本就完成了。</p><h2 id="小人的组成"><a href="#小人的组成" class="headerlink" title="小人的组成"></a>小人的组成</h2><p>本次试验中，先从简单的情况入手，我先将小人分成了身体、头、左臂、右臂、左腿、右腿五个部分，五个部分用树结构链接，其中身体是根节点，其他的均是其子节点。 <img src="/2017/04/05/computer-graphics-experiment-ii-part-2-3d-boxman/boxman-213x300.png"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Man() &#123;</span><br><span class="line">body = Box(Vector3d(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>), Vector3d(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), Vector3d(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">body.color = Vector3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line"><span class="keyword">int</span> angArm = <span class="built_in">sin</span>(time/<span class="number">100</span>) * <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> angLeg= <span class="built_in">sin</span>(time/<span class="number">100</span>) * <span class="number">10</span>;</span><br><span class="line">Box *head = <span class="keyword">new</span> Box(Vector3d(<span class="number">0</span>,<span class="number">-0.5</span>,<span class="number">1</span>),Vector3d(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">Box *lArm = <span class="keyword">new</span> Box(Vector3d(<span class="number">0</span>,<span class="number">0.8</span>,<span class="number">0</span>),Vector3d(<span class="number">0.8</span>,<span class="number">0.8</span>,<span class="number">2</span>),</span><br><span class="line">Vector3d(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">Vector3d(<span class="number">-0.5</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">angArm);</span><br><span class="line">Box *rArm = <span class="keyword">new</span> Box(Vector3d(<span class="number">0</span>,<span class="number">-2</span>,<span class="number">0</span>),Vector3d(<span class="number">0.8</span>,<span class="number">0.8</span>,<span class="number">2</span>),</span><br><span class="line">Vector3d(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>),</span><br><span class="line">Vector3d(<span class="number">-0.5</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">angArm);</span><br><span class="line">Box *lLeg = <span class="keyword">new</span> Box(Vector3d(<span class="number">0</span>,<span class="number">-0.1</span>,<span class="number">-3</span>),Vector3d(<span class="number">0.8</span>,<span class="number">0.8</span>,<span class="number">2</span>),</span><br><span class="line">Vector3d(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>),</span><br><span class="line">Vector3d(<span class="number">-0.5</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">angLeg);</span><br><span class="line">Box *rLeg = <span class="keyword">new</span> Box(Vector3d(<span class="number">0</span>,<span class="number">-1.1</span>,<span class="number">-3</span>),Vector3d(<span class="number">0.8</span>,<span class="number">0.8</span>,<span class="number">2</span>),</span><br><span class="line">Vector3d(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">Vector3d(<span class="number">-0.5</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">angLeg);</span><br><span class="line">body.addNxt(head);</span><br><span class="line">body.addNxt(lArm);</span><br><span class="line">body.addNxt(rArm);</span><br><span class="line">body.addNxt(lLeg);</span><br><span class="line">body.addNxt(rLeg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意下这两句<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> angArm = <span class="built_in">sin</span>(time/<span class="number">100</span>) * <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> angLeg= <span class="built_in">sin</span>(time/<span class="number">100</span>) * <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p>计算了胳膊和腿根据time的摆动（旋转）角度，需要注意的是，在后面调用时注意其正负号，避免出现顺拐的情况(x 其中，Box是一个封装起来的长方体，主要包括了一个长方体、颜色、旋转点、旋转轴、存储树结构的指针数组等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">double</span> angle;</span><br><span class="line">Vector3d base, scale, rotN, color, rotP;</span><br><span class="line">Box* nxt[maxnxt];</span><br><span class="line">Box() &#123; </span><br><span class="line">angle = <span class="number">0</span>;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">color = Vector3d(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">rotP = Vector3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Box(Vector3d base_, Vector3d scale_,</span><br><span class="line">Vector3d rotN_=Vector3d(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">Vector3d rotP_=Vector3d(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line"><span class="keyword">double</span> angle_=<span class="number">0</span>,</span><br><span class="line">Vector3d color_ = Vector3d(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">angle = angle_;</span><br><span class="line">base = base_;</span><br><span class="line">scale = scale_;</span><br><span class="line">rotN = rotN_;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">rotP = rotP_;</span><br><span class="line">color = color_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">glPushMatrix();</span><br><span class="line"><span class="keyword">if</span> (rotN.norm() != <span class="number">0</span>) &#123;</span><br><span class="line">glTranslated(rotP.x(), rotP.y(), rotP.z());<span class="comment">//平移到旋转点</span></span><br><span class="line">glRotated(angle, rotN.x(), rotN.y(), rotN.z());<span class="comment">//旋转</span></span><br><span class="line">glTranslated(-rotP.x(), -rotP.y(), -rotP.z());<span class="comment">//平移回去</span></span><br><span class="line">&#125;</span><br><span class="line">glColor3d(color.x(), color.y(), color.z());</span><br><span class="line">glTranslated(base.x(), base.y(), base.z());</span><br><span class="line">drawBox(Vector3d(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),scale);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">glPushMatrix();</span><br><span class="line">nxt[i]-&gt;draw();</span><br><span class="line">glPopMatrix();</span><br><span class="line">&#125;</span><br><span class="line">glPopMatrix();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNxt</span><span class="params">(Box *x)</span> </span>&#123;</span><br><span class="line">nxt[len] = x;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>大部分的组成都介绍的差不多了，当然这个系统还是比较简单，调试时除了写相机系统时由于没有坐标系没有很方便的找出错误，另外深度测试时卡了一会儿之外剩下的还算蛮顺利，具体代码请移步<a href="https://github.com/Bluefissure/WalkingMan" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Computer Graphics Experiment II Part.1 3D Touring</title>
      <link href="/2017/04/02/computer-graphics-experiment-ii/"/>
      <url>/2017/04/02/computer-graphics-experiment-ii/</url>
      
        <content type="html"><![CDATA[<p>图形学实验二，主要是写了3D的空间漫游以及Walking Boxman两个东西，用了一下午加一晚上。 先放一下效果：(我大B站时不时傲娇，加载不出来播放器的话烦请移步<a href="http://www.bilibili.com/video/av9570127/" target="_blank" rel="noopener">av9570127</a>)  然后具体的实现主要分为两部分，3D场景漫游和机器人的绘画与动作，本篇博文先着重介绍3D漫游部分，机器人部分留作下一篇博文再做介绍。<br><a id="more"></a></p><h2 id="UNV相机及变换"><a href="#UNV相机及变换" class="headerlink" title="UNV相机及变换"></a>UNV相机及变换</h2><p>首先UNV相机主要由三个单位向量表示：</p><ul><li>$\overrightarrow { n } $:指向目标的视线向量</li><li>$\overrightarrow { u } $:指向相机右方的向量</li><li>$\overrightarrow { v } $:指向相机上方的向量</li></ul><p>而这三个组成的向量可以由下面三个向量（点）来求得：</p><ul><li>$\overrightarrow { pos } $:相机位置</li><li>$\overrightarrow { target } $:视线目标位置</li><li>$\overrightarrow { up } $:指向空间上方的向量</li></ul><p>具体的计算公式为： </p><script type="math/tex; mode=display">\begin{cases} \overrightarrow { n } =\overrightarrow { target } -\overrightarrow { pos }  \\ \overrightarrow { u } =\overrightarrow { up } \times \overrightarrow { n }  \\ \overrightarrow { v } =\overrightarrow { u } \times \overrightarrow { n }  \end{cases}</script><p>有了这几个向量，我们就可以首先实现平移变换了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GLCamera::slide(<span class="keyword">float</span> du, <span class="keyword">float</span> dv, <span class="keyword">float</span> dn,<span class="keyword">float</span> dup)</span><br><span class="line">&#123;</span><br><span class="line">    m_pos(<span class="number">0</span>) = m_pos(<span class="number">0</span>) + du*u.x() + dv*v.x() + dn*n.x() + dup*m_up.x();</span><br><span class="line">    m_pos(<span class="number">1</span>) = m_pos(<span class="number">1</span>) + du*u.y() + dv*v.y() + dn*n.y() + dup*m_up.y();</span><br><span class="line">    m_pos(<span class="number">2</span>) = m_pos(<span class="number">2</span>) + du*u.z() + dv*v.z() + dn*n.z() + dup*m_up.z();</span><br><span class="line">    m_target(<span class="number">0</span>) = m_target(<span class="number">0</span>) + du*u.x() + dv*v.x() + dn*n.x() + dup*m_up.x();</span><br><span class="line">    m_target(<span class="number">1</span>) = m_target(<span class="number">1</span>) + du*u.y() + dv*v.y() + dn*n.y() + dup*m_up.y();</span><br><span class="line">    m_target(<span class="number">2</span>) = m_target(<span class="number">2</span>) + du*u.z() + dv*v.z() + dn*n.z() + dup*m_up.z();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，du dv dn dup分别是在$\overrightarrow { u } $, $\overrightarrow { v } $, $\overrightarrow { n } $, $\overrightarrow { up } $向量方向上面的平移距离。 然后将键盘的按键事件与函数绑定，在display函数中调用glulookAt函数就好了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gluLookAt(cam.m_pos.x(), cam.m_pos.y(), cam.m_pos.z(), </span><br><span class="line">    cam.m_target.x(), cam.m_target.y(), cam.m_target.z(), </span><br><span class="line">    cam.m_up.x(), cam.m_up.y(), cam.m_up.z())</span><br></pre></td></tr></table></figure></p><h2 id="鼠标的移动与视野变换"><a href="#鼠标的移动与视野变换" class="headerlink" title="鼠标的移动与视野变换"></a>鼠标的移动与视野变换</h2><p>鼠标的移动产生视野的变换似乎是一个比较麻烦的事情，但是实际上这种视野的变换无非是一系列对unv三个向量的旋转操作，下面从两个维度说明下鼠标的移动对视野产生的影响应该怎么计算： <img src="/2017/04/02/computer-graphics-experiment-ii/unv.png"></p><h3 id="x方向变化——鼠标左右移动"><a href="#x方向变化——鼠标左右移动" class="headerlink" title="x方向变化——鼠标左右移动"></a>x方向变化——鼠标左右移动</h3><p>如图，结合我们多年守望先锋的经验，左右移动鼠标是$\overrightarrow { u } $ $\overrightarrow { n } $ 两个向量绕着$\overrightarrow { v } $ 进行旋转，实际上，我们只需要将$\overrightarrow { n } $进行旋转后计算出旋转后对应的$\overrightarrow { target } $向量，并重新应用之前的计算公式计算$\overrightarrow { u } $ $\overrightarrow { n } $ $\overrightarrow { v } $。</p><h3 id="y方向变化——鼠标上下移动"><a href="#y方向变化——鼠标上下移动" class="headerlink" title="y方向变化——鼠标上下移动"></a>y方向变化——鼠标上下移动</h3><p>同样的，结合我们多年76对空打法鸡的经验，上下移动鼠标是$\overrightarrow { v } $ $\overrightarrow { n } $ 两个向量绕着$\overrightarrow { u } $ 进行旋转，实际上，我们也只需要将$\overrightarrow { n } $进行旋转后计算出旋转后对应的$\overrightarrow { target } $向量，并重新应用之前的计算公式计算$\overrightarrow { u } $ $\overrightarrow { n } $ $\overrightarrow { v } $。   注意下代码中的$x$ $y$和上面所说的$x$ $y$是反的，由于默认的二维数组是$x$为行，$y$为列……<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passiveMotion</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLint deltax = oldx - x;</span><br><span class="line">    GLint deltay = oldy - y;</span><br><span class="line">    GLfloat xAngle = <span class="number">360</span> * (GLfloat)deltay / (GLfloat)WinH;</span><br><span class="line">    GLfloat yAngle = <span class="number">360</span> * (GLfloat)deltax / (GLfloat)WinW;</span><br><span class="line">    yAngle = <span class="number">360</span> - yAngle;</span><br><span class="line">    xAngle = <span class="number">360</span> - xAngle;</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    glRotated(xAngle, cam.u.x(), cam.u.y(), cam.u.z());<span class="comment">//上下移动</span></span><br><span class="line">    glRotated(yAngle, cam.v.x(), cam.v.y(), cam.v.z());<span class="comment">//左右移动</span></span><br><span class="line">    GLfloat m[<span class="number">16</span>];</span><br><span class="line">    glGetFloatv(GL_MODELVIEW_MATRIX, m);</span><br><span class="line">    glPopMatrix();</span><br><span class="line">    Eigen::Matrix3d rot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            rot(i, j) = m[i * <span class="number">4</span> + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cam.n = rot*cam.n;</span><br><span class="line">    cam.m_target = Eigen::Vector3d(cam.m_pos.x() - cam.n.x(), cam.m_pos.y() - cam.n.y(), cam.m_pos.z() - cam.n.z());</span><br><span class="line">    cam.upduvn();</span><br><span class="line">    oldx = x;</span><br><span class="line">    oldy = y;</span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里这个项目的目前实现了的3D漫游功能和实现的过程就差不多介绍完了，还有很多的相机旋转的函数并没有在这里用到，更具体的代码请移步<a href="https://github.com/Bluefissure/WalkingMan" target="_blank" rel="noopener">github</a> 下一篇博文——<a href="">3D Boxman</a></p>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Google  Kickstart Round A 2017</title>
      <link href="/2017/03/06/google-kickstart-round-a-2017/"/>
      <url>/2017/03/06/google-kickstart-round-a-2017/</url>
      
        <content type="html"><![CDATA[<p>好辣鸡啊……第一题推了一个小时后后期瞬间爆炸……太久不敲代码了已经成了咸鱼干…… 今天补了一下题，在这里记录一下。<br><a id="more"></a><br><a href="https://codejam.withgoogle.com/codejam/contest/dashboard?c=8284486#s=p0" target="_blank" rel="noopener">Problem A. Square Counting</a></p><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>Mr. Panda has recently fallen in love with a new game called Square Off, in which players compete to find as many different squares as possible on an evenly spaced rectangular grid of dots. To find a square, a player must identify four dots that form the vertices of a square. Each side of the square must have the same length, of course, but it does not matter what that length is, and the square does not necessarily need to be aligned with the axes of the grid. The player earns one point for every different square found in this way. Two squares are different if and only if their sets of four dots are different. Mr. Panda has just been given a grid with <strong>R</strong> rows and <strong>C</strong> columns of dots. How many different squares can he find in this grid? Since the number might be very large, please output the answer modulo 109 + 7 (1000000007).</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input gives the number of test cases, <strong>T</strong>. <strong>T</strong> lines follow. Each line has two integers <strong>R</strong> and <strong>C</strong>: the number of dots in each row and column of the grid, respectively.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is the test case number (starting from 1) and <code>y</code> is the number of different squares can be found in the grid.</p><h3 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h3><p>1 ≤ <strong>T</strong> ≤ 100.</p><h4 id="Small-dataset"><a href="#Small-dataset" class="headerlink" title="Small dataset"></a>Small dataset</h4><p>2 ≤ <strong>R</strong> ≤ 1000. 2 ≤ <strong>C</strong> ≤ 1000.</p><h4 id="Large-dataset"><a href="#Large-dataset" class="headerlink" title="Large dataset"></a>Large dataset</h4><p>2 ≤ <strong>R</strong> ≤ 109. 2 ≤ <strong>C</strong> ≤ 109.</p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Input</p><p>Output</p><p>4<br>2 4<br>3 4<br>4 4<br>1000 500</p><p>Case #1: 3<br>Case #2: 10<br>Case #3: 20<br>Case #4: 624937395</p><p>The pictures below illustrate the grids from the three sample cases and a valid square in the third sample case. <img src="https://codejam.withgoogle.com/codejam/contest/images/?image=sample1.png&amp;p=5680283126857728&amp;c=8284486" alt=""> <img src="https://codejam.withgoogle.com/codejam/contest/images/?image=sample2.png&amp;p=5680283126857728&amp;c=8284486" alt=""> <img src="https://codejam.withgoogle.com/codejam/contest/images/?image=sample3.png&amp;p=5680283126857728&amp;c=8284486" alt=""></p><p><strong>题目大意：</strong> 给出一个$ n \times m$的正方形点阵，也就是$ (n-1) \times (m-1) $的棋盘，问存在多少个格点正方形（注意如最后一个图的倾斜的正方形也要计算）</p><p><strong>做法：</strong> 默默推公式……一开始没注意倾斜的正方形导致方向错了好久，之后推导的过程还算顺利……叭（哭） </p><p><strong>推导过程：</strong> 首先，我们考虑$ i \times i$的方阵中存在多少能够“充满”整个方阵的格点多边形，“充满”意味着不会存在某一行或者某一列的方格与正方形没有相交的部分，我们先看$ i = 5$的情况：</p><img src="/2017/03/06/google-kickstart-round-a-2017/1-300x296.png"> <p>为了方便我们考虑所有的情况，上图举了个倾斜的例子。<br>对于边长是$i$的方阵，我们有$p + q = i$，因此我们只需要统计方程$p + q = i$有多少非负整数解，显然有$i+1$种，但是$\begin{cases} p=i \\ q=0 \end{cases}$和$\begin{cases} p=0 \\ q=i \end{cases}$是同一种，因此总共有$i$种情况，而$n$行存在$n-i+1$个长度为$i$的方阵，$m$列存在$m-i+1$个长度为$i$的方阵，乘起来求和最终结果是：</p><script type="math/tex; mode=display">\sum _{ i=1 }^{ min(n,m) }{ i\times (n-i+1)\times (m-i+1) }</script><p>这样的结果求小数据是没问题了，大数据还是会TLE，我们需要求出求和公式。<br>求和公式的求法就不在这儿详述了，懒的话直接用<a href="http://www.wolframalpha.com/input/?i=sum(i*(n-i%2B1)*(m-i%2B1),i,1,m)" target="_blank" rel="noopener">WolframAlpha</a>求也行。<br>最后公式是：(假设 $m&lt;{n}$)</p><script type="math/tex; mode=display">\frac { (2n-m+1)\cdot (m+1)\cdot (m+2)\cdot m }{ 12 }</script><p>取模过程的分母12的话逆元也好直接除也好，自行处理都不难：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> LL MOD=<span class="number">1000000007</span>;</span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(!b)&#123;</span><br><span class="line">x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">LL ans=exgcd(b,a%b,y,x);</span><br><span class="line">y-=x*(a/b);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a,LL mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL x,y;</span><br><span class="line">LL d=exgcd(a,mod,x,y);</span><br><span class="line"><span class="keyword">if</span>(d==<span class="number">1</span>) <span class="keyword">return</span> (x+mod)%mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    LL N,M;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    LL inv12=inv(<span class="number">12</span>,MOD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cas=<span class="number">1</span>;cas&lt;=T;cas++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N,&amp;M);</span><br><span class="line">        N--,M--;</span><br><span class="line">        <span class="keyword">if</span>(N&lt;M) swap(N,M);</span><br><span class="line">        LL ans=(<span class="number">2</span>*N+<span class="number">1</span>-M)%MOD*(M+<span class="number">1</span>)%MOD*(M+<span class="number">2</span>)%MOD*M%MOD*inv12%MOD;</span><br><span class="line">        (ans+=MOD)%=MOD;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,cas,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> <a href="https://codejam.withgoogle.com/codejam/contest/dashboard?c=8284486#s=p1" target="_blank" rel="noopener">Problem B. Patterns Overlap</a></p><h3 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem"></a>Problem</h3><p>Alice likes reading and buys a lot of books. She stores her books in two boxes; each box is labeled with a pattern that matches the titles of all of the books stored in that box. A pattern consists of only uppercase/lowercase English alphabet letters and stars (<code>*</code>). A star can match between zero and four letters. For example, books with the titles <code>GoneGirl</code> and <code>GoneTomorrow</code> can be put in a box with the pattern <code>Gone**</code>, but books with the titles <code>TheGoneGirl</code>, and <code>GoneWithTheWind</code> cannot. Alice is wondering whether there is any book that could be stored in either of the boxes. That is, she wonders if there is a title that matches both boxes’ patterns.</p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input gives the number of test cases, <strong>T</strong>. <strong>T</strong> test cases follow. Each consists of two lines; each line has one string in which each character is either an uppercase/lowercase English letter or <code>*</code>.</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is the test case number (starting from 1) and <code>y</code> is <code>TRUE</code> if there is a string that matches both patterns, or <code>FALSE</code> if not.</p><h3 id="Limits-1"><a href="#Limits-1" class="headerlink" title="Limits"></a>Limits</h3><p>1 ≤ <strong>T</strong> ≤ 50.</p><h4 id="Small-dataset-1"><a href="#Small-dataset-1" class="headerlink" title="Small dataset"></a>Small dataset</h4><p>1 ≤ the length of each pattern ≤ 200. Each pattern contains at most 5 stars.</p><h4 id="Large-dataset-1"><a href="#Large-dataset-1" class="headerlink" title="Large dataset"></a>Large dataset</h4><p>1 ≤ the length of each pattern ≤ 2000.</p><h3 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h3><p>Input</p><p>Output</p><p>3<br>****<br>It<br>Shakes<em>e<br>S</em>speare<br>Shakes<em>e</em>peare<br>Case #1: TRUE<br>Case #2: TRUE<br>Case #3: FALSE</p><p><strong>题目大意：</strong> 给了两个模式串，类似通配符的方式，*能代表任意0~4个字符，问是否存在一个字符串能同时匹配这两个模式串。 </p><p><strong>做法：</strong> 啊竟然是dp，首先把每个*扩展成4个，然后用一个dp转移方程xjb转移就行，复杂度是$O({ n }^{ 2 })$的，讲道理最坏情况是$8000 \times 8000$，但是大数据跑了6s也是能得到结果……讲道理大数据的实现是8min呢…… 转移的过程如下：用$dp[i][j]$表示$s$串匹配到$i$，$p$串匹配到$j$能否成功匹配： </p><script type="math/tex; mode=display">if\quad dp[i][j]\quad then\\ \quad \quad \quad \quad \begin{cases} dp[i+1][j]|=s[i+1]=='*' \\ dp[i][j+1]|=p[j+1]=='*' \\ dp[i+1][j+1]|=s[i+1]=='*'||p[j+1]=='*'||s[i+1]==p[j+1] \end{cases}</script><p>简单解释下转移方程，首先，如果$s$的第$i+1$位是’*‘，那么可以从前一位$[i][j]$的状态转移过来，$p$同理，另外，如果$s[i+1]==p[j+1]$，状态也是可以可达的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000</span></span><br><span class="line"><span class="keyword">char</span> s[MAXN],p[MAXN],t[MAXN];</span><br><span class="line"><span class="keyword">bool</span> f[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,len,ls,lp;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cas=<span class="number">1</span>;cas&lt;=T;cas++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,t);</span><br><span class="line">        len=<span class="built_in">strlen</span>(t);</span><br><span class="line">        ls=lp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">if</span>(t[i]==<span class="string">'*'</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">4</span>;k;k--) s[++ls]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> s[++ls]=t[i];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,t);</span><br><span class="line">        len=<span class="built_in">strlen</span>(t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">if</span>(t[i]==<span class="string">'*'</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">4</span>;k;k--) p[++lp]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> p[++lp]=t[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=ls;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=lp;j++)</span><br><span class="line">                f[i][j]=<span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=ls;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=lp;j++)</span><br><span class="line">                <span class="keyword">if</span>(f[i][j])&#123;</span><br><span class="line">                    f[i+<span class="number">1</span>][j]|=!s[i+<span class="number">1</span>];</span><br><span class="line">                    f[i][j+<span class="number">1</span>]|=!p[j+<span class="number">1</span>];</span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>]|=!s[i+<span class="number">1</span>]||!p[j+<span class="number">1</span>]||s[i+<span class="number">1</span>]==p[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>,cas);</span><br><span class="line">        <span class="built_in">puts</span>(f[ls][lp]?<span class="string">"TRUE"</span>:<span class="string">"FALSE"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> <a href="https://codejam.withgoogle.com/codejam/contest/dashboard?c=8284486#s=p2" target="_blank" rel="noopener">Problem C. Space Cubes</a></p><h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem"></a>Problem</h2><p>“Look at the stars, look how they shine for you.” - Coldplay, “Yellow” In a galaxy far, far away, there are many stars. Each one is a sphere with a certain position (in three-dimensional space) and radius. It is possible for stars to overlap each other. The stars are so incredibly beautiful to you that you want to capture them forever! You would like to build two cubes of the same integer edge length, and place them in space such that for each star, there is at least one cube that _completely_ contains it. (It’s not enough for a star to be completely contained by the union of the two cubes.) A star is completely contained by a cube if no point on the star is outside the cube; a point exactly on a cube face is still considered to be inside the cube. The cubes can be placed anywhere in space, but they must be placed with their edges parallel to the coordinate axes. It is acceptable for the cubes to overlap stars or each other. What is the minimum integer edge length that allows you to achieve this goal?</p><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>The input starts with one line containing exactly one integer <strong>T</strong>, which is the number of test cases. <strong>T</strong> test cases follow. Each test case begins with a line containing an integer, <strong>N</strong>, representing the number of stars. This is followed by <strong>N</strong> lines. On the ith line, there are 4 space-separated integers, <strong>Xi</strong>, <strong>Yi</strong>, <strong>Zi</strong>and <strong>Ri</strong>, indicating the (X, Y, Z) coordinates of the center of the <strong>ith</strong> star, and the radius of the <strong>ith</strong> star.</p><h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is the test case number (starting from 1) and <code>y</code> is the minimum cube edge length that solves the problem, as described above.</p><h3 id="Limits-2"><a href="#Limits-2" class="headerlink" title="Limits"></a>Limits</h3><p>1 ≤ <strong>T</strong> ≤ 100.<br>-108 ≤ <strong>Xi</strong> ≤ 108, for all i.<br>-108 ≤ <strong>Yi</strong> ≤ 108, for all i.<br>-108 ≤ <strong>Zi</strong> ≤ 108, for all i.<br>1 ≤ <strong>Ri</strong> ≤ 108, for all i.</p><h4 id="Small-dataset-2"><a href="#Small-dataset-2" class="headerlink" title="Small dataset"></a>Small dataset</h4><p>1 ≤ <strong>N</strong> ≤ 16.</p><h4 id="Large-dataset-2"><a href="#Large-dataset-2" class="headerlink" title="Large dataset"></a>Large dataset</h4><p>1 ≤ <strong>N</strong> ≤ 2000.</p><h3 id="Sample-2"><a href="#Sample-2" class="headerlink" title="Sample"></a>Sample</h3><p>Input</p><p>Output</p><p>3<br>3<br>1 1 1 1<br>2 2 2 1<br>4 4 4 1<br>3<br>1 1 1 2<br>2 3 4 1<br>5 6 7 1<br>3<br>1 1 1 1<br>1 1 1 1<br>9 9 9 1</p><p>Case #1: 3<br>Case #2: 5<br>Case #3: 2</p><p><strong>题目大意：</strong> 三维空间给$n$个球，用两个相同的cube包含所有的球，求cube的最小棱长。 </p><p><strong>做法：</strong> 首先求出来最小包围cube，然后枚举两个cube在最小包围cube的八个顶点的哪个位置，对于每种情况二分棱长。 （感谢qqq的思路……没想到会这么简单……） </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0xfffffffffffffff</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL x,y,z,r;</span><br><span class="line">&#125;p[<span class="number">2010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL mx,my,mz;</span><br><span class="line">    LL Mx,My,Mz;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mx=my=mz=INF;</span><br><span class="line">        Mx=My=Mz=-INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(pl p)</span></span>&#123;</span><br><span class="line">        mx=min(mx,p.x-p.r);</span><br><span class="line">        my=min(my,p.y-p.r);</span><br><span class="line">        mz=min(mz,p.z-p.r);</span><br><span class="line">        Mx=max(Mx,p.x+p.r);</span><br><span class="line">        My=max(My,p.y+p.r);</span><br><span class="line">        Mz=max(Mz,p.z+p.r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;c;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">incube</span><span class="params">(pl p,cb c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> f=c.mx&lt;=(p.x-p.r)&amp;&amp;(p.x+p.r)&lt;=c.Mx;</span><br><span class="line">    f&amp;=c.my&lt;=(p.y-p.r)&amp;&amp;(p.y+p.r)&lt;=c.My;</span><br><span class="line">    f&amp;=c.mz&lt;=(p.z-p.r)&amp;&amp;(p.z+p.r)&lt;=c.Mz;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,LL l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cb c1,c2;</span><br><span class="line">    <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        c1.mx=c.mx;</span><br><span class="line">        c1.Mx=c1.mx+l;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        c1.Mx=c.Mx;</span><br><span class="line">        c1.mx=c1.Mx-l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&amp;<span class="number">2</span>)&#123;</span><br><span class="line">        c1.my=c.my;</span><br><span class="line">        c1.My=c1.my+l;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        c1.My=c.My;</span><br><span class="line">        c1.my=c1.My-l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&amp;<span class="number">4</span>)&#123;</span><br><span class="line">        c1.mz=c.mz;</span><br><span class="line">        c1.Mz=c1.mz+l;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        c1.Mz=c.Mz;</span><br><span class="line">        c1.mz=c1.Mz-l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        c2.mx=c.mx;</span><br><span class="line">        c2.Mx=c2.mx+l;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        c2.Mx=c.Mx;</span><br><span class="line">        c2.mx=c2.Mx-l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&amp;<span class="number">2</span>)&#123;</span><br><span class="line">        c2.my=c.my;</span><br><span class="line">        c2.My=c2.my+l;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        c2.My=c.My;</span><br><span class="line">        c2.my=c2.My-l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&amp;<span class="number">4</span>)&#123;</span><br><span class="line">        c2.mz=c.mz;</span><br><span class="line">        c2.Mz=c2.mz+l;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        c2.Mz=c.Mz;</span><br><span class="line">        c2.mz=c2.Mz-l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!incube(p[i],c1)&amp;&amp;!incube(p[i],c2))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cas=<span class="number">1</span>;cas&lt;=T;cas++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        c.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;p[i].x,&amp;p[i].y,&amp;p[i].z,&amp;p[i].r);</span><br><span class="line">            c.input(p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        LL ex,ey,ez;</span><br><span class="line">        ex=max(c.Mx-c.mx,c.Mx-c.mx);</span><br><span class="line">        ey=max(c.My-c.my,c.My-c.my);</span><br><span class="line">        ez=max(c.Mz-c.mz,c.Mz-c.mz);</span><br><span class="line">        LL rr=max(ex,max(ey,ez));</span><br><span class="line">        <span class="comment">//printf("rr:%lld\n",rr);</span></span><br><span class="line">        LL ans=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">                LL l=<span class="number">0</span>,r=rr;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r<span class="number">-1</span>)&#123; LL mid=l+((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(check(i,j,mid)) r=mid;</span><br><span class="line">                    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(;check(i,j,r<span class="number">-1</span>);r--);</span><br><span class="line">                ans=min(ans,r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,cas,ans);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python模拟登陆初探</title>
      <link href="/2017/01/11/python-e6-a8-a1-e6-8b-9f-e7-99-bb-e9-99-86-e5-88-9d-e6-8e-a2/"/>
      <url>/2017/01/11/python-e6-a8-a1-e6-8b-9f-e7-99-bb-e9-99-86-e5-88-9d-e6-8e-a2/</url>
      
        <content type="html"><![CDATA[<p>　　嘛，学校上线了新的教务系统和选课系统，然后之前的刷课之类的脚本就要重写辣。之前的版本是学长用Java写的一个模拟登陆之类的脚本，然而作为两年都没用Java写过工程类代码的我来说，“人生苦短，我用Python”，于是便花了四个小时写了个新的脚本，具体的方式在这里记录一下，供自己以后回顾以及萌萌哒学弟学妹们参考。<br><a id="more"></a></p><p>　　首先，我也是第一次写这种带些“黑科技”性质的脚本，如果有不完善的地方欢迎大家提出问题，进行讨论。大体的思路是：设定一个间隔时间，不断地查询某个课程的剩余容量，发现有课余量的时候便开始选课。</p><p>　　因此，脚本需要实现的主要有三个模块：模拟登陆模块、查询课余量模块、选课模块，下面分别对三个模块进行说明：</p><h2 id="模拟登陆"><a href="#模拟登陆" class="headerlink" title="模拟登陆"></a>模拟登陆</h2><p>我们先来看一下登录界面<br><img src="/2017/01/11/python-e6-a8-a1-e6-8b-9f-e7-99-bb-e9-99-86-e5-88-9d-e6-8e-a2/1.png"><br>啊，大概长这样，在cmd里ping一下域名找到IP<br><img src="/2017/01/11/python-e6-a8-a1-e6-8b-9f-e7-99-bb-e9-99-86-e5-88-9d-e6-8e-a2/2.png"><br>然后打开Wireshark，对IP地址添加filter，过滤掉其他信息<br><img src="/2017/01/11/python-e6-a8-a1-e6-8b-9f-e7-99-bb-e9-99-86-e5-88-9d-e6-8e-a2/3.png"><br>刷新网页，登录，则记录了通信过程的数据包（121开头的IP为本机，202为网站的IP）<br><img src="/2017/01/11/python-e6-a8-a1-e6-8b-9f-e7-99-bb-e9-99-86-e5-88-9d-e6-8e-a2/4.png"><br>很明显带着login的那个东西传送的是登录信息，打开看看：<br>果然，直接POST了一个类型为application/x-www-form-urlencoded的数据给了子目录/b/ajaxLogin，数据内容为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"j_username"</span> = <span class="string">"学号"</span></span><br><span class="line"><span class="string">"j_password"</span> = <span class="string">"密码"</span></span><br></pre></td></tr></table></figure></p><p>于是，我们同样的将数据以这种形式封装，并用Python模拟HTTP请求发送给<a href="http://bkjwxk.sdu.edu.cn/b/ajaxLogin" target="_blank" rel="noopener">http://bkjwxk.sdu.edu.cn/b/ajaxLogin</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(username,password)</span>:</span></span><br><span class="line">urlLogin=<span class="string">'http://bkjwxk.sdu.edu.cn/b/ajaxLogin'</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">"j_username"</span>: username,</span><br><span class="line"><span class="string">"j_password"</span>: password,</span><br><span class="line">&#125;</span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">'utf-8'</span>) <span class="comment">#注意编码</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line"><span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36'</span>,</span><br><span class="line"><span class="string">'Accept'</span>: <span class="string">'*/*'</span>,</span><br><span class="line"><span class="string">'Origin'</span>: <span class="string">'http://bkjwxk.sdu.edu.cn'</span>,</span><br><span class="line"><span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line"><span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line"><span class="string">'Accept-Encoding'</span>:<span class="string">' gzip, deflate'</span>,</span><br><span class="line"><span class="string">'Host'</span>: <span class="string">'bkjwxk.sdu.edu.cn'</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=urlLogin, headers=headers, data=data)</span><br><span class="line">cookie = http.cookiejar.CookieJar()</span><br><span class="line">opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cookie))</span><br><span class="line"></span><br><span class="line">r = opener.open(request) </span><br><span class="line">response = r.read().decode(<span class="string">'utf-8'</span>)<span class="comment">#注意解码</span></span><br><span class="line">print(response)</span><br><span class="line"><span class="keyword">if</span>(response!=<span class="string">'"success"'</span>): </span><br><span class="line">print(<span class="string">"登陆失败"</span>)</span><br><span class="line">sys.exit()</span><br><span class="line">print(<span class="string">"登陆成功"</span>)</span><br><span class="line"><span class="keyword">return</span> cookie;</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">print(<span class="string">"Login Error: %s"</span>%e)</span><br></pre></td></tr></table></figure></p><p>几点需要注意的地方：</p><ol><li>header中的Content-Type最为重要，它规定了数据发送的形式。而header的其他内容加不加好像都可以得到正确的结果</li><li>注意cookie的获取和保存，这里使用了http.cookiejar.CookieJar</li></ol><p>之后，如果登陆成功会返回”success”，不成功则返回了提示信息，我们可以通过打印response来看到。 登陆成功的话，就能返回cookie进行下一步对课程剩余量的爬虫了。</p><h2 id="爬取剩余课程容量"><a href="#爬取剩余课程容量" class="headerlink" title="爬取剩余课程容量"></a>爬取剩余课程容量</h2><p>如同刚才的做法，先在网页中模拟对课余量的查询，然后抓包分析数据包内容，这里不再详述，直接看发送和接受的数据包的结果：<br><img src="/2017/01/11/python-e6-a8-a1-e6-8b-9f-e7-99-bb-e9-99-86-e5-88-9d-e6-8e-a2/kchsearch.png"><br><img src="/2017/01/11/python-e6-a8-a1-e6-8b-9f-e7-99-bb-e9-99-86-e5-88-9d-e6-8e-a2/kchsearch_res.png"><br>厉害了，发送格式是application/x-www-form-urlencoded，返回直接返回了json，这样分析就方便多了，具体数据代表的含义的话简单地说一下，具体还是自己抓了包看吧：<br>发送信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Form item: <span class="string">"currentPage"</span> = <span class="string">"1"</span> <span class="comment">#当前页号</span></span><br><span class="line">Form item: <span class="string">"kch"</span> = <span class="string">"0063209110"</span> <span class="comment">#课程号</span></span><br></pre></td></tr></table></figure></p><p>接受信息：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JavaScript Object Notation: application/json</span><br><span class="line">Object</span><br><span class="line">Member Key: "result"#成功与否</span><br><span class="line">String value: success</span><br><span class="line">Member Key: "msg"#不成功的话提示信息</span><br><span class="line">Null value</span><br><span class="line">Member Key: "object"#返回数据</span><br><span class="line">Object</span><br><span class="line">Member Key: "perPageNum"#每一页的课程数量</span><br><span class="line">Member Key: "totalRows"</span><br><span class="line">Member Key: "totalPages"#一共多少页</span><br><span class="line">Member Key: "currentPage"#当前页</span><br><span class="line">Member Key: "prePage"#前一页</span><br><span class="line">Member Key: "nextPage"#后一页</span><br><span class="line">Member Key: "startIndex"#本页开始的Index</span><br><span class="line">Member Key: "lastIndex"#本页结束的Index</span><br><span class="line">Member Key: "resultList"#结果数组</span><br><span class="line">Array</span><br></pre></td></tr></table></figure></p><p>然后直接操作json中的Array那个数组，对应的什么KCM属性对应课程名，根据拼音猜一猜就好，找出查询课程的的课序号，如果剩余量大于零则开始选课。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkLeft</span><span class="params">(kch,kxh,cookie)</span>:</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">urlCheck=urlbase+<span class="string">'/b/xk/xs/kcsearch'</span></span><br><span class="line">curPage = <span class="number">1</span></span><br><span class="line">totPage = <span class="number">100</span></span><br><span class="line">find = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">while</span>(curPage &lt;= totPage <span class="keyword">and</span> <span class="keyword">not</span> find):</span><br><span class="line"><span class="comment"># print("curPage %d"%curPage)</span></span><br><span class="line"><span class="comment"># print("totPage %d"%totPage)</span></span><br><span class="line"><span class="comment"># print("kch %s"%kch)</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">"type"</span>: <span class="string">"kc"</span>,</span><br><span class="line"><span class="string">"currentPage"</span>: curPage,</span><br><span class="line"><span class="string">"kch"</span>: kch,</span><br><span class="line"><span class="string">"jsh"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"skxq"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"skjc"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"kkxsh"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for item in cookie:</span></span><br><span class="line"><span class="comment"># print('%s : %s' % (item.name,item.value))</span></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=urlCheck, headers=headers, data=data)</span><br><span class="line">cj = cookie</span><br><span class="line">opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))</span><br><span class="line">r = opener.open(request) </span><br><span class="line">response = r.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"login"</span> <span class="keyword">in</span> response):</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> <span class="comment">#Cookie espire</span></span><br><span class="line">jsondata = json.loads(response)</span><br><span class="line"></span><br><span class="line">totPage = int(jsondata[<span class="string">"object"</span>][<span class="string">"totalPages"</span>])</span><br><span class="line">curPage = curPage + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> jsondata[<span class="string">"object"</span>][<span class="string">"resultList"</span>]:</span><br><span class="line"><span class="comment">#print(item.get("KXH"))</span></span><br><span class="line"><span class="keyword">if</span>(int(item.get(<span class="string">"KXH"</span>))==int(kxh)):</span><br><span class="line">find = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span>(int(item.get(<span class="string">"kyl"</span>))&gt;<span class="number">0</span>):</span><br><span class="line"><span class="keyword">if</span>(xuanke(kch,kxh,cookie)):</span><br><span class="line">print(<span class="string">"课程\"%s\"选课成功，谢谢使用\nBy Bluefissure"</span>%(item.get(<span class="string">"KCM"</span>)))</span><br><span class="line">sys.exit()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">"课程\"%s\"课余量不足，您需要等待至少 %s 人退课"</span>%(item.get(<span class="string">"KCM"</span>),-int(item.get(<span class="string">"kyl"</span>))+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span> find):</span><br><span class="line">print(<span class="string">"找不到该课程，请确认课程号、课序号!"</span>)</span><br><span class="line">sys.exit()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">print(<span class="string">"Check Error: %s"</span>%e)</span><br></pre></td></tr></table></figure></p><h2 id="选课过程"><a href="#选课过程" class="headerlink" title="选课过程"></a>选课过程</h2><p>选课过程老简单了，直接看抓包的数据如下：<br><img src="/2017/01/11/python-e6-a8-a1-e6-8b-9f-e7-99-bb-e9-99-86-e5-88-9d-e6-8e-a2/xuanke.png"><br>厉害了，直接访问下/b/xk/xs/add/课程号/课序号 就好了，代码太简单都不用贴的…… 然后返回的内容还是json，提示信息是utf-8编码（中文），在wireshark里好像显示不正确：<br><img src="/2017/01/11/python-e6-a8-a1-e6-8b-9f-e7-99-bb-e9-99-86-e5-88-9d-e6-8e-a2/xuanke_res.png"><br>在Python里解码就好了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xuanke</span><span class="params">(kch,kxh,cookie)</span>:</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">urlXuanke=<span class="string">'http://bkjwxk.sdu.edu.cn/b/xk/xs/add/%s/%s'</span>%(kch,kxh)</span><br><span class="line">request = urllib.request.Request(url=urlXuanke)</span><br><span class="line">cj = cookie</span><br><span class="line">opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))</span><br><span class="line">r = opener.open(request) </span><br><span class="line">response = r.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">result = json.loads(response)[<span class="string">"msg"</span>]</span><br><span class="line">print(result)</span><br><span class="line"><span class="keyword">return</span>(<span class="string">"选课成功"</span> <span class="keyword">in</span> result)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">print(<span class="string">"Check Error: %s"</span>%e)</span><br></pre></td></tr></table></figure></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li>Cookie可能过期，因此每次访问时如果发现有重定向至Login页面的返回时，要重新登录更新cookie</li><li>其实系统架构大可不必检测课余量，直接暴力强行选就行，反正新系统的接口这么方便……但是，嘛，总感觉暴力去搞有一些<a href="https://baike.baidu.com/item/dos/5104226" target="_blank" rel="noopener">DOS</a>的感觉，不要这样搞为好（有人看了这篇博客后去DOS的话那是最骚的）</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>发现bug的话欢迎来<a href="https://github.com/Bluefissure/SDU_Scripts" target="_blank" rel="noopener">github</a>提吖，测试并没有怎么做。<br>本脚本仅做学习交流用途，请勿将其大规模用于实践。<br>作者并未参与一切类似功能的发行版软件的开发，使用本脚本以及同类发行版软件的责任请由使用者自负。</p><p>喵喵。</p>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>莫比乌斯反演 学习笔记</title>
      <link href="/2016/08/18/e8-8e-ab-e6-af-94-e4-b9-8c-e6-96-af-e5-8f-8d-e6-bc-94-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0/"/>
      <url>/2016/08/18/e8-8e-ab-e6-af-94-e4-b9-8c-e6-96-af-e5-8f-8d-e6-bc-94-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0/</url>
      
        <content type="html"><![CDATA[<p>当时数论学到莫比乌斯暂时放下了，现在重新拿起来学习一下<br><a id="more"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>已知 </p><script type="math/tex; mode=display">F(n)=\sum_{d\mid n}f(d)</script><p>则有 </p><script type="math/tex; mode=display">f(n)=\sum_{d\mid n}\mu(d)F({n\over d})</script><p>其中$\mu(d)$叫做莫比乌斯函数,其值为</p><script type="math/tex; mode=display">\mu(d)=\begin{cases} 1 &\text{d = 1}\\ (-1)^r &\text{$d=p_1p_2…p_r,其中p_i为不同的素数$}\\ 0 &\text{else} \end{cases}</script><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>1.</p><script type="math/tex; mode=display">\sum _{ d|n }^{  }{ \mu (d)= } \begin{cases} 1,\quad n=1 \\ 0,\quad n>1 \end{cases}\\</script><p>证明如下:</p><p>$\bullet$ $n=1$时,显然</p><p>$\bullet$ $n\neq 1$时,将$n$分解$n={ { p }_{ 1 } }^{ { a }_{ 1 } }{ { p }_{ 2 } }^{ { a }_{ 2 } }…{ { p }_{ k } }^{ { a }_{ k } }$, $\mu$值不为0的只有质因子次数均为1的因子,其中质因子个数为$r$的因子有$C_{k}^{r}$个,所以</p><script type="math/tex; mode=display">\sum _{ d|n }^{  }{ \mu (d) } =C_{ k }^{ 0 }-C_{ k }^{ 1 }+C_{ k }^{ 2 }-...+{ (-1) }^{ k }C_{ k }^{ k }=\sum _{ i=0 }^{ k }{ { (-1) }^{ i }C_{ k }^{ i } } ={ (-1+1) }^{ k }=0</script><p>2.</p><script type="math/tex; mode=display">\sum _{ d|n }^{  }{ \frac { \mu (d) }{ d }  } =\frac { \varphi (n) }{ n }\\</script><p>证明如下:</p><p>由欧拉函数性质知$n=\sum _{ d|n }^{  }{ \varphi (n) }$, 设$F(n)=n,\quad f(n)=\varphi (n)$, 有$f(n)=\varphi (n)=\sum _{ d|n }^{  }{ \mu (d) } \cdot \frac { n }{ d } $,故$\sum _{ d|n }^{  }{ \frac { \mu (d) }{ d }  } =\frac { \varphi (n) }{ n } $</p><p>3.$\mu(n)$为积性函数</p><h2 id="反演定理的证明"><a href="#反演定理的证明" class="headerlink" title="反演定理的证明"></a>反演定理的证明</h2><script type="math/tex; mode=display">\begin{align} \sum _{ d|n }^{  }{ \mu (d)\cdot F(\frac { n }{ d } ) } &=\sum _{ d|n }^{  }{ \left[ \mu (d)\sum _{ k|\frac { n }{ d }  }^{  }{ f(k) }  \right]  } \\ &=\sum _{ d|n }^{  }{ \sum _{ d|\frac { n }{ k }  }^{  }{ \left[ \mu (d)\cdot f(k) \right]  }  } \\ &=\sum _{ dk|n }^{  }{ \left[ \mu (d)\cdot f(k) \right]  } \\ &=\sum _{ k|n }^{  }{ \left[ f(k)\sum _{ d|\frac { n }{ k }  }^{  }{ \mu (d) }  \right]  } =f(n) \end{align}</script><p>其中,$\sum _{ d|\frac { n }{ k }  }^{  }{ \mu (d) } $的计算用到了性质1</p><h2 id="另一种形式"><a href="#另一种形式" class="headerlink" title="另一种形式"></a>另一种形式</h2><p>莫比乌斯公式还有一种常用的形式较为常用： </p><script type="math/tex; mode=display">F(d)=\sum _{ d|n }^{  }{ f(n) } \Rightarrow f(d)=\sum _{ d|n } \mu ({ \frac { n }{ d }  })F(n)</script><p>证明同理 </p><h2 id="题目相关"><a href="#题目相关" class="headerlink" title="题目相关"></a>题目相关</h2><p>嗯，今天做了几道懵逼乌斯的题目感觉的确蛮懵逼的，主要是各种公式的推导过程很是不熟悉，看来还是要多刷题加深对于反演的理解</p><h3 id="1-区间内-gcd-x-y-k-对数查询"><a href="#1-区间内-gcd-x-y-k-对数查询" class="headerlink" title="1.区间内$gcd(x,y)=k$对数查询"></a>1.区间内$gcd(x,y)=k$对数查询</h3><p>这是第一类的莫比乌斯反演的应用问题，详细的题意为”求满足$a\le x\le b, c\le y\le d$范围内，$gcd(x,y)=k$的$(x,y)$数对有多少个”。<br>首先，我们将问题转化成四个子问题，如果$sol(a,b)$表示$1\le x\le a, 1\le y\le b$范围内满足题意的$(x,y)$数对有多少个，那么最后的答案$ans$便为</p><script type="math/tex; mode=display">ans=sol(b,d)-sol(a-1,d)-sol(c-1,b)+sol(a-1,c-1)</script><p>于是，我们只需要解决$1\le x\le a, 1\le y\le b$范围内$gcd(x,y)=k$的个数。<br>显然，这个问题等价于$1\le x\le \frac { a }{ k } ,1\le y\le \frac { b }{ k } $范围内$gcd(x,y)=1$的个数。<br>于是，我们考虑这个元问题：$1\le x\le n ,1\le y\le m $范围内$gcd(x,y)=1$的个数<br>不妨假设$n\le m$ 我们用$f(k)$表示$gcd(x,y)=k$的个数，用$F(k)$表示$k|gcd(x,y)$的个数，则有</p><script type="math/tex; mode=display">F(d)=\sum _{ d|n }^{  }{ f(n) }</script><p>显然</p><script type="math/tex; mode=display">F(x)=\left\lfloor \frac { n }{ x }  \right\rfloor \cdot \left\lfloor \frac { m }{ x }  \right\rfloor</script><p>根据反演公式</p><script type="math/tex; mode=display">f(i)=\sum _{ i|d } \mu ({ \frac { d }{ i }  })F(d)=\sum _{ i|d } \mu ({ \frac { d }{ i }  })\cdot \left\lfloor \frac { n }{ d }  \right\rfloor \cdot \left\lfloor \frac { m }{ d }  \right\rfloor</script><p>有</p><script type="math/tex; mode=display">f(1)=\sum _{ d\le n } \mu ({ d })\cdot \left\lfloor \frac { n }{ d }  \right\rfloor \cdot \left\lfloor \frac { m }{ d }  \right\rfloor</script><p>于是我们枚举一下$d$就能得出结果啦。 </p><p>等等，枚举？范围稍稍大一点就铁定TLE啊，我们考虑</p><script type="math/tex; mode=display">\left\lfloor \frac { n }{ d }  \right\rfloor</script><p>这个东西，显然他不是随着$d$的变化一定都变化的，而是只会有$O(\sqrt { n } )$个取值，具体的原因在新生赛热身的<a href="http://acm.sdu.edu.cn/problem/20/" target="_blank" rel="noopener">这道题</a> 的题解中有简单提到。<br>因此，我们对</p><script type="math/tex; mode=display">\left\lfloor \frac { n }{ d }  \right\rfloor \cdot \left\lfloor \frac { m }{ d }\right\rfloor</script><p>这个东西相同取值的块求区间内$\mu $的和即可，在实际的操作过程中只需要维护一个$\mu $的前缀和。 代码以 <a href="http://www.lydsy.com/JudgeOnline/problem.php?id=2301" target="_blank" rel="noopener">BZOJ_2301</a> 为例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> prim[N], phi[N] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;, mob[N]=&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> pn = <span class="number">0</span>;</span><br><span class="line">LL sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">table</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    mob[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            prim[pn++] = i;</span><br><span class="line">            phi[i] = i<span class="number">-1</span>;</span><br><span class="line">            mob[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; pn &amp;&amp; <span class="number">1L</span>L*i*prim[j] &lt; N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % prim[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                phi[i*prim[j]] = phi[i] * prim[j];</span><br><span class="line">                vis[i*prim[j]] = <span class="number">1</span>;</span><br><span class="line">                mob[i*prim[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i*prim[j]] = phi[i] * (prim[j]<span class="number">-1</span>);</span><br><span class="line">            vis[i*prim[j]] = <span class="number">1</span>;</span><br><span class="line">            mob[i*prim[j]] = -mob[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++) sum[i]=sum[i<span class="number">-1</span>]+mob[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">sol</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    LL ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) swap(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i=last+<span class="number">1</span>)&#123;</span><br><span class="line">        last=min(n/(n/i),m/(m/i));</span><br><span class="line">        ret+=(LL)(n/i)*(m/i)*(sum[last]-sum[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    table();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);T--;)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        LL ans=sol(b/k,d/k)-sol((a<span class="number">-1</span>)/k,d/k)-sol((c<span class="number">-1</span>)/k,b/k)+sol((a<span class="number">-1</span>)/k,(c<span class="number">-1</span>)/k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-区间内-gcd-x-y-为质数的对数查询"><a href="#2-区间内-gcd-x-y-为质数的对数查询" class="headerlink" title="2.区间内$gcd(x,y)$为质数的对数查询"></a>2.区间内$gcd(x,y)$为质数的对数查询</h3><p>同1.可转化成元问题：$1\le x\le n ,1\le y\le m $范围内$gcd(x,y)$为质数的$(x,y)$数对个数 $(n\le m)$ 一个非常直观（或说偷懒）的办法就是对于所有的质数$p$满足$p\le n$我们用1.的方法搞出$gcd(x,y)=p$的个数然后加起来……啊喂怎么可能这么简单辣……<br>但是这个想法给了我们一个思路，我们先来看</p><script type="math/tex; mode=display">f(p)=\sum _{ d\le n/p }^{  }{ \mu (d)\cdot \left\lfloor \frac { n/p }{ d }  \right\rfloor \cdot \left\lfloor \frac { m/p }{ d }  \right\rfloor = } \sum _{ d\le n/p }^{  }{ \mu (d)\cdot \left\lfloor \frac { n }{ pd }  \right\rfloor \cdot \left\lfloor \frac { m }{ pd }  \right\rfloor  }</script><p>令$T=pd$，有</p><script type="math/tex; mode=display">f(p)=\sum _{ d\le n/p }^{  }{ \mu (\frac { T }{ p } )\cdot \left\lfloor \frac { n }{ T }  \right\rfloor \cdot \left\lfloor \frac { m }{ T }  \right\rfloor  }</script><p>有</p><script type="math/tex; mode=display">\begin{align} \sum _{ p\le n }^{  }{ f(p) } &=\sum _{ p\le n }^{  }{ \sum _{ d\le n/p }^{  }{ \mu (\frac { T }{ p } )\cdot \left\lfloor \frac { n }{ T }  \right\rfloor \cdot \left\lfloor \frac { m }{ T }  \right\rfloor  }  } \\ &=\sum _{ T=1 }^{ n }{ \sum _{ p|T }^{  }{ \mu (\frac { T }{ p } )\cdot \left\lfloor \frac { n }{ T }  \right\rfloor \cdot \left\lfloor \frac { m }{ T }  \right\rfloor  }  } \\ &=\sum _{ T=1 }^{ n }{ \left\lfloor \frac { n }{ T }  \right\rfloor \cdot \left\lfloor \frac { m }{ T }  \right\rfloor \sum _{ p|T }^{  }{ \mu (\frac { T }{ p } ) }  }  \end{align}</script><p>(以上$p$均为质数，下同）<br>$\left\lfloor \frac { n }{ T }  \right\rfloor \cdot \left\lfloor \frac { m }{ T }  \right\rfloor $可以分块来搞，后面的这个$\sum _{ p|T }^{  }{ \mu (\frac { T }{ p } ) } $就不太好弄了，我们先来研究一下它</p><h4 id="函数-g-x-sum-p-x-mu-frac-x-p"><a href="#函数-g-x-sum-p-x-mu-frac-x-p" class="headerlink" title="函数$g(x)=\sum _{ p|x }^{  }{ \mu (\frac { x }{ p } ) } $"></a>函数$g(x)=\sum _{ p|x }^{  }{ \mu (\frac { x }{ p } ) } $</h4><p>首先，我们先来说它的计算过程中用到的一个性质，之后再给出证明</p><script type="math/tex; mode=display">g(kp)=\begin{cases} \mu (k),\quad p\mid k \\ \mu (k)-g(k),\quad p\nmid k \end{cases}</script><p>证明：首先</p><script type="math/tex; mode=display">g(kp)=\sum _{ p'|kp }^{  }{ \mu (\frac { kp }{ p' } ) }</script><p>（$p’$为质数，下同）我们把$k$分解</p><script type="math/tex; mode=display">k={ p }^{ a }\cdot { p }_{ 1 }^{ { a }_{ 1 } }\cdot { p }_{ 2 }^{ { a }_{ 2 } }...{ p }_{ r }^{ { a }_{ r } }</script><p>1.当$p|k$时，有$a\ge 1$,故</p><script type="math/tex; mode=display">kp={ p }^{ a+1 }\cdot { p }_{ 1 }^{ { a }_{ 1 } }\cdot { p }_{ 2 }^{ { a }_{ 2 } }...{ p }_{ r }^{ { a }_{ r } }</script><p>由$\mu$的定义可知，只有$p’=p$时，$\mu (\frac { kp }{ p’ } ) $才不等于0（否则$p$的指数比1大），所以此时</p><script type="math/tex; mode=display">\sum _{ p'|kp }^{  }{ \mu (\frac { kp }{ p' } ) } =\mu (k)</script><p>2.当$p\nmid k$时 $p’=p$时，同上文：</p><script type="math/tex; mode=display">\mu (\frac { kp }{ p' } )=\mu (k)</script><p>$p’\ne p$时，因为$\mu $是一个积性函数，并且$p\nmid \frac { k }{ p’ } $，所以有</p><script type="math/tex; mode=display">\mu (\frac { kp }{ p' } )=\mu (\frac { k }{ p' } )\cdot \mu(p)</script><p>有</p><script type="math/tex; mode=display">g(kp){ | }_{ p\ne p' }=\sum _{ p'|kp ,p'\ne p }^{  }{ \mu (\frac { kp }{ p' } ) } =\sum _{ p'|kp,p'\ne p }^{  }{ \mu (\frac { k }{ p' } )\cdot \mu (p) } =\mu (p)\cdot \sum _{ p'|k }^{  }{ \mu (\frac { k }{ p' } ) }</script><p>而</p><script type="math/tex; mode=display">\mu (p)=-1,\sum _{ p'|k }^{  }{ \mu (\frac { k }{ p' } ) } =g(k)</script><p>所以</p><script type="math/tex; mode=display">g(kp){ | }_{ p\ne p' }=-g(k)</script><p>上面两个加起来，就得到了</p><script type="math/tex; mode=display">\mu (k)-g(k),\quad p\nmid k</script><p>综上，</p><script type="math/tex; mode=display">g(kp)=\begin{cases} \mu (k),\quad p\mid k \\ \mu (k)-g(k),\quad p\nmid k \end{cases}</script><p>回想一下我们线性筛的过程，发现对于$p|k$和$p\nmid k$的讨论正是线性筛的过程，因此我们可以预处理出$g(x)$，然后的做法就和问题1差不多了，具体的预处理过程看代码还是。 貌似一道叫做 YY的GCD 的题目成了权限题，于是代码只好以 <a href="http://www.spoj.com/problems/PGCD/" target="_blank" rel="noopener">SPOJ_PGCD </a>为例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> prim[N], phi[N] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;, mob[N]=&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,g[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> pn = <span class="number">0</span>;</span><br><span class="line">LL sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">table</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    mob[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            prim[pn++] = i;</span><br><span class="line">            phi[i] = i<span class="number">-1</span>;</span><br><span class="line">            mob[i] = <span class="number">-1</span>;</span><br><span class="line">            g[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; pn &amp;&amp; <span class="number">1L</span>L*i*prim[j] &lt; N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % prim[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                phi[i*prim[j]] = phi[i] * prim[j];</span><br><span class="line">                vis[i*prim[j]] = <span class="number">1</span>;</span><br><span class="line">                mob[i*prim[j]] = <span class="number">0</span>;</span><br><span class="line">                g[i*prim[j]] = mob[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i*prim[j]] = phi[i] * (prim[j]<span class="number">-1</span>);</span><br><span class="line">            vis[i*prim[j]] = <span class="number">1</span>;</span><br><span class="line">            mob[i*prim[j]] = -mob[i];</span><br><span class="line">            g[i*prim[j]] = mob[i] - g[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++) sum[i]=sum[i<span class="number">-1</span>]+g[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">sol</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    LL ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) swap(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i=last+<span class="number">1</span>)&#123;</span><br><span class="line">        last=min(n/(n/i),m/(m/i));</span><br><span class="line">        ret+=(LL)(n/i)*(m/i)*(sum[last]-sum[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret-(LL)m*n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,cas=<span class="number">1</span>;</span><br><span class="line">    table();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);T--;)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        LL ans;</span><br><span class="line">        ans=sol(a,b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-还有好多其他类型的题，到时候单独写博客吧……我也没做完……"><a href="#3-还有好多其他类型的题，到时候单独写博客吧……我也没做完……" class="headerlink" title="3.还有好多其他类型的题，到时候单独写博客吧……我也没做完……"></a>3.还有好多其他类型的题，到时候单独写博客吧……我也没做完……</h3><p>收尾的话差不多了，总结的话有时间再写，打那么多公式简直累死了……</p>]]></content>
      
      
      <categories>
          
          <category> Math Theory </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HDU 5816 Hearthstone 状压</title>
      <link href="/2016/08/09/hdu-5816-hearthstone-e7-8a-b6-e5-8e-8b/"/>
      <url>/2016/08/09/hdu-5816-hearthstone-e7-8a-b6-e5-8e-8b/</url>
      
        <content type="html"><![CDATA[<h1 id="Hearthstone"><a href="#Hearthstone" class="headerlink" title="Hearthstone"></a>Hearthstone</h1><h3 id="2016-Multischool-Training-7-1008"><a href="#2016-Multischool-Training-7-1008" class="headerlink" title="2016 Multischool-Training-7-1008"></a>2016 Multischool-Training-7-1008</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5816" target="_blank" rel="noopener">题目连接</a></p><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>n张奥术智慧，m张分别会造成$X_i$点伤害的火球术，不计法力消耗，求斩杀剩下P点HP的对手的概率。<br><a id="more"></a></p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>压缩下m张火球术选择与否的状态，然后DFS……为了避免MLE用了vector存的……（虽然貌似数组就能过……）</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">int</span> att[MAXN],n,m,p,T;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">frac</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll up, low;</span><br><span class="line">    </span><br><span class="line">    frac(ll up = <span class="number">0</span>, ll low = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; <span class="number">0</span>) up = -up, low = -low;</span><br><span class="line">        assert(low);</span><br><span class="line">        ll g = __gcd(<span class="built_in">abs</span>(up), low);</span><br><span class="line">        <span class="keyword">this</span>-&gt;up = up / g, <span class="keyword">this</span>-&gt;low = low / g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll g = __gcd(<span class="built_in">abs</span>(up), low);</span><br><span class="line">        <span class="keyword">this</span>-&gt;up /= g;</span><br><span class="line">           <span class="keyword">this</span>-&gt;low /= g;</span><br><span class="line">        <span class="keyword">if</span>(up==<span class="number">0</span>) low=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>, up, low);</span><br><span class="line">    &#125;</span><br><span class="line">    frac <span class="keyword">operator</span> + (<span class="keyword">const</span> frac &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> frac(up * b.low + low * b.up, low * b.low);</span><br><span class="line">    &#125;</span><br><span class="line">    frac <span class="keyword">operator</span> - (<span class="keyword">const</span> frac &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> frac(up * b.low - low * b.up, low * b.low);</span><br><span class="line">    &#125;</span><br><span class="line">    frac <span class="keyword">operator</span> * (<span class="keyword">const</span> frac &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> frac(up * b.up, low * b.low);</span><br><span class="line">    &#125;</span><br><span class="line">    frac <span class="keyword">operator</span> / (<span class="keyword">const</span> frac &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> frac(up * b.low, low * b.up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> frac &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> up * b.low &lt; low * b.up;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> frac &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> up * b.low == low * b.up;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> frac&amp; b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> b &lt; *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> frac&amp; b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(b &lt; *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> frac &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> frac &amp;b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> up * b.low != low * b.up;</span><br><span class="line">    &#125;</span><br><span class="line">    frac <span class="keyword">operator</span> += (<span class="keyword">const</span> frac &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + b;</span><br><span class="line">    &#125;</span><br><span class="line">    frac <span class="keyword">operator</span> -= (<span class="keyword">const</span> frac &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>*<span class="keyword">this</span> = *<span class="keyword">this</span> - b;</span><br><span class="line">    &#125;</span><br><span class="line">    frac <span class="keyword">operator</span> *= (<span class="keyword">const</span> frac &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * b;</span><br><span class="line">    &#125;</span><br><span class="line">    frac <span class="keyword">operator</span> /= (<span class="keyword">const</span> frac &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;frac&gt; dp[<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">frac <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> st,<span class="keyword">int</span> p,<span class="keyword">int</span> left)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> frac(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    frac &amp;res=dp[n][st];</span><br><span class="line">    <span class="keyword">if</span>(res!=frac(<span class="number">-1</span>,<span class="number">1</span>)) <span class="keyword">return</span> res;</span><br><span class="line">    res=frac(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=<span class="number">0</span>) <span class="keyword">return</span> res=frac(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(left&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res=frac(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cm=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> mm=(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>((st&amp;mm)==<span class="number">0</span>) cm++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=n+cm)&#123;</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> mm=(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">            <span class="keyword">if</span>((st&amp;(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))==<span class="number">0</span>) tot+=att[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=tot) <span class="keyword">return</span> res=frac(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res=frac(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res+=dfs(n<span class="number">-1</span>,st,p,left+<span class="number">1</span>)*frac(n,n+cm);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> mm=(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>((st&amp;mm)==<span class="number">0</span>)&#123;</span><br><span class="line">            res+=(dfs(n,st|mm,p-att[i],left<span class="number">-1</span>)*frac(<span class="number">1</span>,n+cm));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim=((<span class="number">1</span>&lt;&lt;(m)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i].resize(lim+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=lim;k++)</span><br><span class="line">            dp[i][k]=frac(<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;p,&amp;n,&amp;m);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;att[i]);</span><br><span class="line">        frac ans=dfs(n,<span class="number">0</span>,p,<span class="number">1</span>);</span><br><span class="line">        ans.output();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Multischool-Training </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HDU 5810 Balls and Boxes 公式 概率与统计</title>
      <link href="/2016/08/09/hdu-5810-balls-and-boxes-e5-85-ac-e5-bc-8f-e6-a6-82-e7-8e-87-e4-b8-8e-e7-bb-9f-e8-ae-a1/"/>
      <url>/2016/08/09/hdu-5810-balls-and-boxes-e5-85-ac-e5-bc-8f-e6-a6-82-e7-8e-87-e4-b8-8e-e7-bb-9f-e8-ae-a1/</url>
      
        <content type="html"><![CDATA[<h1 id="Balls-and-Boxes"><a href="#Balls-and-Boxes" class="headerlink" title="Balls and Boxes"></a>Balls and Boxes</h1><h3 id="2016-Multischool-Training-7-1002"><a href="#2016-Multischool-Training-7-1002" class="headerlink" title="2016 Multischool-Training-7-1002"></a>2016 Multischool-Training-7-1002</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5810" target="_blank" rel="noopener">题目连接</a></p><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>$n$个球随机扔到$m$个箱子中，求每个箱子中所放球$X_i$的方差的期望。<br><a id="more"></a></p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>推公式……</p><script type="math/tex; mode=display">\begin{align}E(V)&=E(\frac { \sum _{ i=1 }^{ m }{ { ({ X }_{ i }-\overline { X } ) }^{ 2 } }  }{ m } )\\ &=E({ ({ X }_{ i }-\overline { X } ) }^{ 2 })\\ &=E({ { X }_{ i } }^{ 2 }-2{ X }_{ i }\cdot \overline { X } +{ \overline { X }  }^{ 2 })\\ &=E({ { X }_{ i } }^{ 2 })-{ \overline { X }  }^{ 2 }\\ &=D({ { X }_{ i } })+{ E({ { X }_{ i } }) }^{ 2 }-{ \overline { X }  }^{ 2 }\\ &=D({ { X }_{ i } })\end{align}</script><p>而${ X }_{ i }\sim B(n,\frac { 1 }{ m } )$，所以${ D(X }_{ i })=n\cdot \frac { 1 }{ m } \cdot (1-\frac { 1 }{ m } )$</p><p>写起来简单，比赛中推了好久……实在是太弱了</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL n,m,p,q;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m),n+m)&#123;</span><br><span class="line">        p=n*(m<span class="number">-1</span>);</span><br><span class="line">        q=m*m;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"0/1"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>,p/__gcd(p,q),q/__gcd(p,q));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Multischool-Training </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Speed up network connection via IPv6 VPS Update 2016-10-24</title>
      <link href="/2016/08/08/speed-up-network-connection-via-ipv6-vps-update-2016-10-24/"/>
      <url>/2016/08/08/speed-up-network-connection-via-ipv6-vps-update-2016-10-24/</url>
      
        <content type="html"><![CDATA[<p>关于如何突破宿舍网速限制顺利学习<a id="more"></a><br><img src="/2016/08/08/speed-up-network-connection-via-ipv6-vps-update-2016-10-24/1.png"> </p><p>首先，这是篇技术文章。<br>学校对宿舍的ipv4速度限制模式是什么样的不太清楚，然而在9:30~24:30大概是很难成功的登入暴雪（网易）的服务器进行学习的，如果在游戏界面等待许久最终出现了这个无法连接学习服务器的界面还是蛮难受的，而且一般这种状况出现就意味着网络条件基本是gg了，即便进入游戏也会卡得动弹不得（UPD9-14：无线模式貌似可以进入，然而卡得要死）。<br>然而我们知道国内的教育网一般都是分配了ipv6的地址，带宽大概在100M左右，众所周知的ipv6架构的PT站之所以在资源共享上有那么快的下载速度也是这个原因，既然这样，我们为什么不可以通过ipv6连接到服务器呢？答案当然是不行的……ipv6还只是测试阶段，基本没有游戏服务器会提供v6的地址链接，因此，我们只能退而求其次，用v6链接一台VPS，然后通过VPS把数据转播出去，具体步骤如下： </p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>一台具有ipv6地址的服务器（VPS、云主机之类），<a href="https://github.com/breakwa11/shadowsocks-rss" target="_blank" rel="noopener">某服务</a>，<a href="http://www.sockscap64.com/" target="_blank" rel="noopener">SocksCap64</a></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>搭建或购买具有v6地址的某服务 (<a href="https://github.com/shadowsocks/shadowsocks/releases" target="_blank" rel="noopener">Win客户端</a>)，详细搭建方法请见 <a href="https://www.google.com/#q=shadowsocks" target="_blank" rel="noopener">这里</a></li><li>通过ipv6地址链接某服务,具体配置如图<img src="/2016/08/08/speed-up-network-connection-via-ipv6-vps-update-2016-10-24/2.png"> </li><li>打开SocksCap，添加SOCKS5代理127.0.0.1:1080，即本机ss端口 <img src="/2016/08/08/speed-up-network-connection-via-ipv6-vps-update-2016-10-24/3.png">添加后测试下代理<img src="/2016/08/08/speed-up-network-connection-via-ipv6-vps-update-2016-10-24/4.png">然后将相关程序添加到程序面版内<img src="/2016/08/08/speed-up-network-connection-via-ipv6-vps-update-2016-10-24/5.png"></li><li>打开链接<img src="/2016/08/08/speed-up-network-connection-via-ipv6-vps-update-2016-10-24/6.png"></li><li>从SocksCap中打开战网，开始学习叭<img src="/2016/08/08/speed-up-network-connection-via-ipv6-vps-update-2016-10-24/7.png"></li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>Update 2016-10-24：如果Ping过高的话解决办法有两个：换用低延迟服务器，或者进了地图之后暂停掉SocksCap</li><li>Update 2016-9-14：通过wireshark抓包发现了问题所在，进入游戏后很多数据是以UDP方式发包，尽管服务器端设置了UDP监听与转发，但是某客户端+SocksCap64的组合貌似对UDP发包支持不太好，因此换成了另外的某客户端，勾选UDP over TCP选项，就能够将UDP包封装在TCP里发送出去</li><li>Update 2016-9-6：进入游戏可能在加载地图后无法选择人物便退出，这时可以尝试切出SockCap暂时停用试试，这种玄学问题怎么解决的我也说不清……</li><li>Update 2016-9-5：由于ProxyCap是付费软件，试用期到了后就换成了SocksCap64，国人开发的一个小东西，支持UDP转发，并且免费，大家喜欢的话可以去<a href="http://www.sockscap64.com/donate" target="_blank" rel="noopener">赞助一下</a> （最新版貌似能够直接添加socks5代理了，更加方便了）</li><li>Update 2016-9-5：好久没学习了，听说都出了新的地图和第二赛季？</li><li>不想自己搭建或者想购shen买shou获得VultrV6体验资格的，可以联系作者获取。（顺带某服务）（学习一点也不耗费流量）</li><li>开黑么？我半蔵源氏76死神DJ大锤都贼不6，Bluefissure #5258</li><li>同样的加速也适用于其他游戏，带宽取决于min(ipv6互联带宽，服务器ipv4出口带宽)，但是链接一些国内的服务器的话速度可能还是比较慢，经过我的尝试国外的服务和有全球CDN的服务（steam之类）能够跑满我服务器10M的带宽，百度云之类的服务确实不如直连快，大家自己多多尝试多多权衡就好。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LightOJ 1336 Sigma Function 数论 有意思</title>
      <link href="/2016/08/06/lightoj-1336-sigma-function-e6-95-b0-e8-ae-ba-e6-9c-89-e6-84-8f-e6-80-9d/"/>
      <url>/2016/08/06/lightoj-1336-sigma-function-e6-95-b0-e8-ae-ba-e6-9c-89-e6-84-8f-e6-80-9d/</url>
      
        <content type="html"><![CDATA[<p><a href="http://lightoj.com/volume_showproblem.php?problem=1336" target="_blank" rel="noopener">题目连接</a><br><a id="more"></a></p><h2 id="1336-Sigma-Function"><a href="#1336-Sigma-Function" class="headerlink" title="1336 - Sigma Function"></a>1336 - Sigma Function</h2><p><a href="http://lightoj.com/volume_showproblem.php?problem=1336&amp;language=english&amp;type=pdf" target="_blank" rel="noopener">PDF (English)</a></p><p><a href="http://lightoj.com/volume_problemstat.php?problem=1336" target="_blank" rel="noopener">Statistics</a></p><p><a href="http://lightoj.com/forum_showproblem.php?problem=1336" target="_blank" rel="noopener">Forum</a></p><p>Time Limit: 2 second(s)</p><p>Memory Limit: 32 MB</p><p>Sigma function is an interesting function in Number Theory. It is denoted by the Greek letter Sigma (σ). This function actually denotes the sum of all divisors of a number. For example σ(24) = 1+2+3+4+6+8+12+24=60. Sigma of small numbers is easy to find but for large numbers it is very difficult to find in a straight forward way. But mathematicians have discovered a formula to find sigma. If the prime power decomposition of an integer is</p><script type="math/tex; mode=display">n={ { p }_{ 1 } }^{ { e }_{ 1 } }\cdot { { p }_{ 2 } }^{ { e }_{ 2 } }\cdot { { p }_{ 3 } }^{ { e }_{ 3 } }...{ { p }_{ k } }^{ { e }_{ k } }</script><p>Then we can write,</p><script type="math/tex; mode=display">\sigma (n)=\frac { { { p }_{ 1 } }^{ { e }_{ 1 }+1 }-1 }{ { p }_{ 1 }-1 } \cdot \frac { { { p }_{ 2 } }^{ { e }_{ 2 }+1 }-1 }{ { p }_{ 2 }-1 } ...\frac { { { p }_{ k } }^{ { e }_{ k }+1 }-1 }{ { p }_{ k }-1 }</script><p>For some <strong>n</strong> the value of <strong>σ(n)</strong> is odd and for others it is even. Given a value <strong>n</strong>, you will have to find how many integers from <strong>1</strong> to <strong>n</strong> have <strong>even</strong> value of <strong>σ</strong>.</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p><p>Each case starts with a line containing an integer <strong>n (1 ≤ n ≤ 1012)</strong>.</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, print the case number and the result.</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><h1 id="Output-for-Sample-Input"><a href="#Output-for-Sample-Input" class="headerlink" title="Output for Sample Input"></a>Output for Sample Input</h1><p>4</p><p>3</p><p>10</p><p>100</p><p>1000</p><p>Case 1: 1</p><p>Case 2: 5</p><p>Case 3: 83</p><p>Case 4: 947</p><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>定义$\sigma (n)$为$n$的因子和，求1～$n$范围内$\sigma$值为偶数的有多少个。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>首先分解$n$, $n=\sum _{ i=1 }^{ r }{ { { p }_{ i } }^{ { a }_{ i } } } $,则$\sigma (n)=\prod _{ i=1 }^{ r }{ (\sum _{ j=0 }^{ { a }_{ i } }{ { { p }_{ i } }^{ j } } ) } $，我们考虑什么情况下$\sigma (n)$为奇数，有</p><ul><li>${ p }_{ i }=2$时，$\sum _{ j=0 }^{ { a }_{ i } }{ { { p }_{ i } }^{ j } } $为奇数</li><li>${ p }_{ i }\neq 2$时，${ a }_{ i } $ 均为偶数时 $\sum _{ j=0 }^{ { a }_{ i } }{ { { p }_{ i } }^{ j } } $为奇数<br>因此，我们发现${ a }_{ i } $均为偶数时，有$\sqrt { n } =\sum _{ i=1 }^{ r }{ { { p }_{ i } }^{ \frac { { a }_{ i } }{ 2 }  } } $为因子和为奇数的个数，但是缺少了2的幂为奇数的情况，共有$\sqrt { \frac { n }{ 2 }  } $种情况，因此最后的答案为$n-\sqrt { n } -\sqrt { \frac { n }{ 2 }  } $</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cas=<span class="number">1</span>;cas&lt;=T;cas++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        LL ans =((LL)<span class="built_in">sqrt</span>(n)+(LL)<span class="built_in">sqrt</span>(n/<span class="number">2.</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>,cas,n-ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math Theory </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HDU 5768 Lucky7 数论 中国剩余定理</title>
      <link href="/2016/07/28/hdu-5768-lucky7-e6-95-b0-e8-ae-ba-e4-b8-ad-e5-9b-bd-e5-89-a9-e4-bd-99-e5-ae-9a-e7-90-86/"/>
      <url>/2016/07/28/hdu-5768-lucky7-e6-95-b0-e8-ae-ba-e4-b8-ad-e5-9b-bd-e5-89-a9-e4-bd-99-e5-ae-9a-e7-90-86/</url>
      
        <content type="html"><![CDATA[<h3 id="2016-Multischool-Training-4-1005"><a href="#2016-Multischool-Training-4-1005" class="headerlink" title="2016 Multischool-Training-4-1005"></a>2016 Multischool-Training-4-1005</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5768" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>给个区间$\left[ x,y \right] $ ， $x,y$ 范围在 ${ 10 }^{ 18 }$ 。</p><p>求问区间内有多少数能被7整除，并且对任意${ p }_{ i }$取模不等于${ a }_{ i }$。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>先算出来被7整除的数的个数，然后对${ p }_{ i }$和${ a }_{ i }$容斥一下，奇减偶加就好，对于多个同余方程组成的同余方程组：$\begin{cases} x\equiv { a }_{ 1 }\left( mod\quad { p }_{ 1 } \right)  \\ x\equiv { a }_{ 2 }\left( mod\quad { p }_{ 2 } \right)  \\ … \\ … \\ x\equiv { a }_{ k }\left( mod\quad { p }_{ k } \right)  \end{cases}$ 用中国剩余定理求解及统计个数。</p><p>需要注意的是在中国剩余定理的过程中可能爆long long，乘法的过程要改成快速乘。(WA了两发QAQ)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL p[MAXN],a[MAXN],x,y;</span><br><span class="line"><span class="keyword">bool</span> op[MAXN];</span><br><span class="line">LL dfsans=<span class="number">0</span>;</span><br><span class="line"><span class="function">LL <span class="title">lcm</span><span class="params">(LL a,LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/__gcd(a,b)*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a,LL b,LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a%=c;</span><br><span class="line">    b%=c;</span><br><span class="line">    LL ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ret+=a;ret%=c;</span><br><span class="line">        &#125;</span><br><span class="line">        a&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=c) a%=c;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=x*(a/b);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">China</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL M=<span class="number">1</span>,Mi,x0,y0,d,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="keyword">if</span>(op[i]) M*=p[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!op[i]) <span class="keyword">continue</span>;</span><br><span class="line">        Mi=M/p[i];</span><br><span class="line">        exgcd(Mi,p[i],x0,y0);</span><br><span class="line">        (x0+=M)%=M;</span><br><span class="line">        LL tt=mul(Mi,x0,M);</span><br><span class="line">        (ans+=mul(tt,a[i],M))%=M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ans&lt;<span class="number">0</span>) (ans+=M)%=M;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sol</span><span class="params">(<span class="keyword">int</span> n,LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL base=China(n);</span><br><span class="line">    LL LCM=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(op[i])</span><br><span class="line">            LCM=lcm(LCM,p[i]);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (x-base)/LCM+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx,LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx==<span class="number">1</span>)</span><br><span class="line">        dfsans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(idx&gt;n)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(op[i])&#123;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        LL tmp=sol(n,x);</span><br><span class="line">        <span class="keyword">if</span>(c&amp;<span class="number">1</span>) dfsans+=tmp;</span><br><span class="line">        <span class="keyword">else</span> dfsans-=tmp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    op[idx]=<span class="number">0</span>;</span><br><span class="line">    dfs(idx+<span class="number">1</span>,x);</span><br><span class="line">    op[idx]=<span class="number">1</span>;</span><br><span class="line">    dfs(idx+<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,LL x,LL y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL LCM=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;p[i],&amp;a[i]);</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">7</span>;a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    op[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    LL cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">    dfsans=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,x<span class="number">-1</span>);</span><br><span class="line">    cnt1=dfsans;</span><br><span class="line">    dfsans=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,y);</span><br><span class="line">    cnt2=dfsans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,cnt2-cnt1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cas=<span class="number">1</span>;cas&lt;=T;cas++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>,cas);</span><br><span class="line">        solve(n,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math Theory </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HDU 5755 Gambler Bo 高斯消元</title>
      <link href="/2016/07/27/hdu-5775-gambler-bo-e9-ab-98-e6-96-af-e6-b6-88-e5-85-83/"/>
      <url>/2016/07/27/hdu-5775-gambler-bo-e9-ab-98-e6-96-af-e6-b6-88-e5-85-83/</url>
      
        <content type="html"><![CDATA[<h3 id="2016-Multischool-Training-3-1004"><a href="#2016-Multischool-Training-3-1004" class="headerlink" title="2016 Multischool-Training-3-1004"></a>2016 Multischool-Training-3-1004</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5755" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先这道题比赛时路子有点野并没有A掉，后来看才发现高斯消元能够很快的求出答案，主要方法类似于反转开关，只是反转开关只有两种操作和两种状态，因此由列出的xor方程便能很容易的异或解出，这个题目有三种操作（点击一次或两次）以及三种状态（0,1,2），因此列出的方程不是异或方程，而是模3域下的加法（即$(x+y)\%3$）。</p><p>对每个点，点击它的次数设为$x_i$，则其对自己的贡献为2，它周围格子对它的贡献为1，他们的和与初始格子上的值的和加起来应该等于0（模3域下），因此可以列出$N\times M$个方程，$N\times M$个变量。</p><p>因为数域是模3域，因此我们可以只用加法消元，高斯消元不再多讲，有自由变元直接取0就行，另外需要注意的是最后求$x_i$的过程中如果常数是1而系数是2需要给常数+3再求得结果（因为是模3域），其他情况如果除不尽则结果为0（因为系数只可能是1或者2），具体不详细讲了，直接看代码就行。</p><p>哦对，高斯消元复杂度 $O({ \left( N\times M \right)  }^{ 3 })$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> range(x,y) (x&gt;=0&amp;&amp;x<span class="meta-string">&lt;N&amp;&amp;y&gt;=0&amp;&amp;y&lt;M)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(a,b) (((a)+(b))%3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getx(i,j) ((i)*M+(j))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> geti(x) ((x)/M)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getj(x) ((x)-(x)/M*M)</span></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x[MAXN];<span class="comment">//answer</span></span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN];<span class="comment">//augmented matrix</span></span><br><span class="line"><span class="keyword">int</span> var,equ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uniqueans</span><span class="params">(<span class="keyword">int</span> var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=var<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!g[i][i])&#123;</span><br><span class="line">            x[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp=g[i][var];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;var;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=((g[i][j]==<span class="number">0</span>)?<span class="number">0</span>:<span class="number">3</span>-g[i][j]);</span><br><span class="line">            tmp+=v*x[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp%g[i][i]==<span class="number">0</span>)</span><br><span class="line">            x[i]=tmp/g[i][i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((tmp+<span class="number">3</span>)%g[i][i]==<span class="number">0</span>)</span><br><span class="line">            x[i]=(tmp+<span class="number">3</span>)/g[i][i];</span><br><span class="line">        <span class="keyword">else</span> x[i]=<span class="number">0</span>;</span><br><span class="line">        x[i]%=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> equ,<span class="keyword">int</span> var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> col,k,maxr;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>,col=<span class="number">0</span>;k&lt;equ&amp;&amp;col&lt;var;k++,col++)&#123;</span><br><span class="line">        maxr=k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;equ;i++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(g[maxr][col])&lt;<span class="built_in">abs</span>(g[i][col]))</span><br><span class="line">                maxr=i;</span><br><span class="line">        <span class="keyword">if</span>(maxr!=k)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=col;i&lt;=var;i++)</span><br><span class="line">                swap(g[k][i],g[maxr][i]);</span><br><span class="line">        <span class="keyword">if</span>(g[k][col]==<span class="number">0</span>)&#123;</span><br><span class="line">            k--;<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;equ;i++)</span><br><span class="line">            <span class="keyword">if</span>(g[i][col]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> v=((g[i][col]+g[k][col]==<span class="number">3</span>)?<span class="number">1</span>:<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=col;j&lt;=var;j++)</span><br><span class="line">                    g[i][j]=f(g[i][j],v*g[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;equ;i++)</span><br><span class="line">        <span class="keyword">if</span>(g[i][var]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//no answer</span></span><br><span class="line">    <span class="comment">//if(k&lt;var) return var-k;//inf answer return number of free vars</span></span><br><span class="line">    uniqueans(var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//ans -&gt; x[]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="keyword">sizeof</span>(x));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">        var=equ=N*M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">                g[getx(i,j)][var]=t==<span class="number">0</span>?<span class="number">0</span>:<span class="number">3</span>-t;</span><br><span class="line">                g[getx(i,j)][getx(i,j)]=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x=i+dx[k],y=j+dy[k];</span><br><span class="line">                    <span class="keyword">if</span>(range(x,y)) g[getx(i,j)][getx(x,y)]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> err=gauss(equ,var);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;var;i++)</span><br><span class="line">            cnt+=(x[i]%=<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;var;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(x[i]--)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,geti(i)+<span class="number">1</span>,getj(i)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Multischool-Training </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HDU 5728 PowMod 数论 欧拉函数</title>
      <link href="/2016/07/20/hdu-5728-powmod/"/>
      <url>/2016/07/20/hdu-5728-powmod/</url>
      
        <content type="html"><![CDATA[<h3 id="2016-Multischool-Training-1-1006"><a href="#2016-Multischool-Training-1-1006" class="headerlink" title="2016 Multischool-Training-1-1006"></a>2016 Multischool-Training-1-1006</h3><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5728" target="_blank" rel="noopener">题目链接</a></h3><a id="more"></a><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先，考虑到$\varphi$是一个积性函数，我们有下面两条性质</p><ul><li>$\varphi (mn)=\varphi (m)\cdot \varphi (n)）\quad (m,n)=1$</li><li>$\varphi (pn)=p\cdot \varphi (n)\quad (p,\frac { n }{ p } )=1$   (p为n的一个质因子)</li></ul><p>我们先来证明一下第二点</p><script type="math/tex; mode=display">\begin{align}\varphi (pn) &=\varphi ({ p }^{ 2 }\cdot \frac { n }{ p } )\\ &=\varphi ({ p }^{ 2 })\cdot \varphi (\frac { n }{ p } )\\ &=p\cdot (p-1)\cdot \varphi (\frac { n }{ p } )\\ &=p\cdot \varphi (p)\cdot \varphi (\frac { n }{ p } )\\ &=p\cdot \varphi (n)\end{align}</script><p>题目中中说明$n$是square-free number，即表明它的每种质因子最多只有一个，因此我们来统计每个质因子对$k$的贡献:</p><p>所求$k=\sum_{i=1}^{m} \varphi (i*n)$  可先将$n$分解质因子，对于每个质因子$p$来说，若$(i,p)=1$则直接由第一条性质拆出来即可，若$i=kp$，则由第二条性质，$\varphi (kpn)=p\cdot \varphi (kn)$，因此对质因子p有</p><script type="math/tex; mode=display">\begin{align}\sum _{ i=1 }^{ m }{ \varphi (i\cdot n) } { | }_{ p } &=\sum _{ i\%p\neq 0 }^{ i=1:m }{ \varphi (i\cdot \frac { n }{ p } )\cdot \varphi (p) } +\sum _{ i=kp }^{ i=1:m }{ \varphi (i\cdot n) } \\ &=\sum _{ i\%p\neq 0 }^{ i=1:m }{ \varphi (i\cdot \frac { n }{ p } )\cdot \varphi (p) } +\sum _{ k=1 }^{ m/p }{ \varphi (k\cdot p\cdot n) } \\ &=\sum _{ i\%p\neq 0 }^{ i=1:m }{ \varphi (i\cdot \frac { n }{ p } )\cdot \varphi (p) } +\sum _{ k=1 }^{ m/p }{ \varphi (k\cdot n)\cdot p } \\ &=\sum _{ i\%p\neq 0 }^{ i=1:m }{ \varphi (i\cdot \frac { n }{ p } )\cdot \varphi (p) } +\sum _{ k=1 }^{ m/p }{ \varphi (k\cdot n)\cdot (\varphi (p)+1) } \\ &=\sum _{ i\%p\neq 0 }^{ i=1:m }{ \varphi (i\cdot \frac { n }{ p } )\cdot \varphi (p) } +\sum _{ k=1 }^{ m/p }{ \varphi (k\cdot n)\cdot \varphi (p) } +\sum _{ k=1 }^{ m/p }{ \varphi (k\cdot n) } \\ &=\sum _{ i\%p\neq 0 }^{ i=1:m }{ \varphi (i\cdot \frac { n }{ p } )\cdot \varphi (p) } +\sum _{ i\%p=0 }^{ i=1:m }{ \varphi (\frac { i }{ p } \cdot n)\cdot \varphi (p) } +\sum _{ k=1 }^{ m/p }{ \varphi (k\cdot n) } \\ &=\sum _{ i=1 }^{ m }{ \varphi (i\cdot \frac { n }{ p } ) } +\sum _{ i=1 }^{ m/p }{ \varphi (i\cdot n) }  \end{align}</script><p>所以我们可以递归求出$k$</p><p>得到$k$后，最后的答案只需要降幂公式降幂即可，$k$的无穷次方终将在递归中降成$\%1$的状态</p><script type="math/tex; mode=display">{ A }^{ B }\%C={ A }^{ B\%\varphi (C)+\varphi (C) }\%C</script><p>比赛中也是找了好多办法求k都没求出来，最后也是参照大牛的博客的方法才知道怎么求的k</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line">LL phi[N],sum[N],pri[N];</span><br><span class="line"><span class="keyword">int</span> top,tp;</span><br><span class="line">LL fac[<span class="number">100</span>];</span><br><span class="line">LL n,m,p;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a,LL b, LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a%=c;</span><br><span class="line">    b%=c;</span><br><span class="line">    LL ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) (ret+=a)%=c;</span><br><span class="line">        (a&lt;&lt;=<span class="number">1</span>)%=c;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL x,LL n,LL mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x%=mod;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    LL tmp=x,ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ret=mul(ret,tmp,mod);</span><br><span class="line">        tmp=mul(tmp,tmp,mod);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">0</span>) ret+=mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            pri[top++]=i;</span><br><span class="line">            phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;top&amp;&amp;i*pri[j]&lt;N;j++)&#123;</span><br><span class="line">            vis[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%pri[j]))&#123;</span><br><span class="line">                phi[i*pri[j]]=phi[i]*pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> phi[i*pri[j]]=phi[i]*(pri[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">        sum[i]=(sum[i<span class="number">-1</span>]+phi[i])%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getfac</span><span class="params">(LL n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;top;i++)&#123;</span><br><span class="line">        LL p1=pri[i];</span><br><span class="line">        <span class="keyword">if</span>(n%p1==<span class="number">0</span>)&#123;</span><br><span class="line">            fac[tp++]=p1;</span><br><span class="line">            n/=p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!vis[n])&#123;</span><br><span class="line">            fac[tp++]=n;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">sol</span><span class="params">(LL k,LL p,LL add)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1l</span>l;</span><br><span class="line">    LL tmp=sol(k,phi[p],phi[p]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(k,tmp,p)+add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL  <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i,LL n,LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> sum[m];</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL pp=fac[i];</span><br><span class="line">    LL k=((pp<span class="number">-1</span>)*calc(i+<span class="number">1</span>,n/pp,m)%MOD+calc(i,n,m/pp))%MOD;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;m,&amp;p))&#123;</span><br><span class="line">        getfac(n);</span><br><span class="line">        LL k=calc(<span class="number">0</span>,n,m);</span><br><span class="line">        LL ans=sol(k,p,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans%p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math Theory </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
